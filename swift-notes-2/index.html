<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <title>Swift 学习笔记（二） | 孙耀珠的博客</title>

    <meta charset="utf-8" />
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <meta
      name="google-site-verification"
      content="zYt2wigM41vmyHtpvOvLHk4Yetcfbv5Bz9pdvsTRT3Y"
    />

    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <meta name="generator" content="Jekyll v4.2.0" />
    <meta property="og:title" content="Swift 学习笔记（二）" />
    <meta name="author" content="孙耀珠" />
    <meta property="og:locale" content="en_US" />
    <meta
      name="description"
      content="结构体和类 结构体和类 结构体（Structure）和类（Class）有以下共同特性：属性（property）、方法（method）、下标（subscript）、构造器（initializer）、扩展（extension）、协议（protocol）；另外类还有以下独有特性：继承（inheritance）、类型转换（type casting）、析构器（deinitializer）、自动引用计数（ARC）。 结构体是值类型，当其进行赋值操作或参数传递时会发生值拷贝，当然编译器也会在此基础上做 copy-on-write 优化；而类是引用类型，相当于通过指针间接访问，因此不会发生值拷贝，但同时 let 关键字和参数传递时不再能保证其指向的内容不被修改。1 对于类的实例来说，相等（equality）不意味着相同（identity），我们可以通过 === / !== 来判断是不是同一个对象。 对结构体和值类型的进一步讨论可以参见 ObjC 中国，对于是选用结构体还是类可以参见 官方文档（优先选用结构体）。 &#8617;"
    />
    <meta
      property="og:description"
      content="结构体和类 结构体和类 结构体（Structure）和类（Class）有以下共同特性：属性（property）、方法（method）、下标（subscript）、构造器（initializer）、扩展（extension）、协议（protocol）；另外类还有以下独有特性：继承（inheritance）、类型转换（type casting）、析构器（deinitializer）、自动引用计数（ARC）。 结构体是值类型，当其进行赋值操作或参数传递时会发生值拷贝，当然编译器也会在此基础上做 copy-on-write 优化；而类是引用类型，相当于通过指针间接访问，因此不会发生值拷贝，但同时 let 关键字和参数传递时不再能保证其指向的内容不被修改。1 对于类的实例来说，相等（equality）不意味着相同（identity），我们可以通过 === / !== 来判断是不是同一个对象。 对结构体和值类型的进一步讨论可以参见 ObjC 中国，对于是选用结构体还是类可以参见 官方文档（优先选用结构体）。 &#8617;"
    />
    <link rel="canonical" href="https://blog.yzsun.me/swift-notes-2/" />
    <meta property="og:url" content="https://blog.yzsun.me/swift-notes-2/" />
    <meta property="og:site_name" content="孙耀珠的博客" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2015-05-02T00:00:00+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Swift 学习笔记（二）" />
    <script type="application/ld+json">
      {
        "description": "结构体和类 结构体和类 结构体（Structure）和类（Class）有以下共同特性：属性（property）、方法（method）、下标（subscript）、构造器（initializer）、扩展（extension）、协议（protocol）；另外类还有以下独有特性：继承（inheritance）、类型转换（type casting）、析构器（deinitializer）、自动引用计数（ARC）。 结构体是值类型，当其进行赋值操作或参数传递时会发生值拷贝，当然编译器也会在此基础上做 copy-on-write 优化；而类是引用类型，相当于通过指针间接访问，因此不会发生值拷贝，但同时 let 关键字和参数传递时不再能保证其指向的内容不被修改。1 对于类的实例来说，相等（equality）不意味着相同（identity），我们可以通过 === / !== 来判断是不是同一个对象。 对结构体和值类型的进一步讨论可以参见 ObjC 中国，对于是选用结构体还是类可以参见 官方文档（优先选用结构体）。 &#8617;",
        "url": "https://blog.yzsun.me/swift-notes-2/",
        "@type": "BlogPosting",
        "headline": "Swift 学习笔记（二）",
        "dateModified": "2015-05-02T00:00:00+00:00",
        "datePublished": "2015-05-02T00:00:00+00:00",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.yzsun.me/swift-notes-2/"
        },
        "author": { "@type": "Person", "name": "孙耀珠" },
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.yzsun.me/feed.xml"
      title="孙耀珠的博客"
    />

    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="/style.css" />
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"
            ><img src="/images/avatar.jpg" alt="avatar"
          /></a>

          <div class="site-info">
            <h1 class="site-domain"><a href="/">yzsun.me</a></h1>
            <p class="site-name">孙耀珠的博客</p>
          </div>

          <nav>
            <a href="/">首页</a>
            <a href="/archive/">归档</a>
            <a href="/about/">关于</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
        <h1>Swift 学习笔记（二）</h1>

        <div class="info">
          <span>
            <i class="fa fa-calendar"></i>
            2015-05-02
          </span>
          <span>
            <i class="fa fa-user"></i>
            孙耀珠
          </span>
          <span>
            <i class="fa fa-tags"></i>
            编程语言
          </span>
        </div>

        <div class="entry">
          <ul id="markdown-toc">
            <li>
              <a href="#结构体和类" id="markdown-toc-结构体和类">结构体和类</a>
            </li>
            <li>
              <a href="#属性" id="markdown-toc-属性">属性</a>
              <ul>
                <li>
                  <a href="#存储属性" id="markdown-toc-存储属性">存储属性</a>
                </li>
                <li>
                  <a href="#计算属性" id="markdown-toc-计算属性">计算属性</a>
                </li>
                <li>
                  <a href="#属性观察器" id="markdown-toc-属性观察器"
                    >属性观察器</a
                  >
                </li>
                <li>
                  <a href="#全局和局部变量" id="markdown-toc-全局和局部变量"
                    >全局和局部变量</a
                  >
                </li>
                <li>
                  <a href="#类型属性" id="markdown-toc-类型属性">类型属性</a>
                </li>
              </ul>
            </li>
            <li>
              <a href="#方法" id="markdown-toc-方法">方法</a>
              <ul>
                <li>
                  <a href="#实例方法" id="markdown-toc-实例方法">实例方法</a>
                </li>
                <li>
                  <a href="#类型方法" id="markdown-toc-类型方法">类型方法</a>
                </li>
              </ul>
            </li>
            <li><a href="#下标" id="markdown-toc-下标">下标</a></li>
            <li><a href="#继承" id="markdown-toc-继承">继承</a></li>
            <li><a href="#类型转换" id="markdown-toc-类型转换">类型转换</a></li>
            <li>
              <a href="#构造器" id="markdown-toc-构造器">构造器</a>
              <ul>
                <li>
                  <a href="#类的构造规则" id="markdown-toc-类的构造规则"
                    >类的构造规则</a
                  >
                </li>
                <li>
                  <a href="#可失败构造器" id="markdown-toc-可失败构造器"
                    >可失败构造器</a
                  >
                </li>
              </ul>
            </li>
            <li><a href="#析构器" id="markdown-toc-析构器">析构器</a></li>
            <li>
              <a href="#自动引用计数" id="markdown-toc-自动引用计数"
                >自动引用计数</a
              >
            </li>
            <li><a href="#协议" id="markdown-toc-协议">协议</a></li>
            <li><a href="#扩展" id="markdown-toc-扩展">扩展</a></li>
            <li><a href="#泛型" id="markdown-toc-泛型">泛型</a></li>
            <li>
              <a href="#错误处理" id="markdown-toc-错误处理">错误处理</a>
              <ul>
                <li><a href="#断言" id="markdown-toc-断言">断言</a></li>
                <li>
                  <a href="#致命错误" id="markdown-toc-致命错误">致命错误</a>
                </li>
              </ul>
            </li>
            <li><a href="#访问控制" id="markdown-toc-访问控制">访问控制</a></li>
            <li>
              <a href="#运算符" id="markdown-toc-运算符">运算符</a>
              <ul>
                <li>
                  <a href="#运算符重载" id="markdown-toc-运算符重载"
                    >运算符重载</a
                  >
                </li>
                <li>
                  <a href="#自定义运算符" id="markdown-toc-自定义运算符"
                    >自定义运算符</a
                  >
                </li>
              </ul>
            </li>
          </ul>

          <h2 id="结构体和类">结构体和类</h2>

          <ul>
            <li>
              结构体（Structure）和类（Class）有以下共同特性：属性（property）、方法（method）、下标（subscript）、构造器（initializer）、扩展（extension）、协议（protocol）；另外类还有以下独有特性：继承（inheritance）、类型转换（type
              casting）、析构器（deinitializer）、自动引用计数（ARC）。
            </li>
            <li>
              结构体是<strong>值类型</strong>，当其进行赋值操作或参数传递时会发生值拷贝，当然编译器也会在此基础上做
              copy-on-write
              优化；而类是<strong>引用类型</strong>，相当于通过指针间接访问，因此不会发生值拷贝，但同时
              <code class="language-plaintext highlighter-rouge">let</code>
              关键字和参数传递时不再能保证其指向的内容不被修改。<sup
                id="fnref:valuetype"
                role="doc-noteref"
                ><a href="#fn:valuetype" class="footnote">1</a></sup
              >
            </li>
            <li>
              对于类的实例来说，相等（equality）不意味着相同（identity），我们可以通过
              <code class="language-plaintext highlighter-rouge">===</code> /
              <code class="language-plaintext highlighter-rouge">!==</code>
              来判断是不是同一个对象。
            </li>
          </ul>

          <!--more-->

          <h2 id="属性">属性</h2>

          <h3 id="存储属性">存储属性</h3>

          <ul>
            <li>
              存储属性（Stored
              property）即存储在结构体或类实例中的变量或常量，其合并了
              Objective-C 中属性（property）和实例变量（instance
              variable）的概念。
            </li>
            <li>
              存储属性必须在定义中或是在构造器中被赋初值，否则应将其定义为可空类型。
            </li>
            <li>
              如果一个结构体的实例是常量，则无法修改其任何属性；而类的实例常量仍可修改其变量属性。
            </li>
            <li>
              使用
              <code class="language-plaintext highlighter-rouge">lazy var</code>
              可以定义一个<strong>惰性存储属性</strong>，该属性将在首次访问时才计算初值。因为实例方法在实例初始化完成前是不可调用的，所以使用惰性存储属性可以绕开这一规则延后调用实例方法为属性设初值。
            </li>
          </ul>

          <h3 id="计算属性">计算属性</h3>

          <ul>
            <li>
              计算属性（Computed property）不直接存储值，而是提供一个 getter
              和一个可选的 setter
              来间接获取和设置其他属性的值。因为计算属性的值是不确定的，所以一定要声明为
              <code class="language-plaintext highlighter-rouge">var</code>。
            </li>
            <li>
              只读计算属性的定义可以省略
              <code class="language-plaintext highlighter-rouge">get</code>
              关键字直接写在第一层大括号里。
            </li>
            <li>
              如果
              <code class="language-plaintext highlighter-rouge">set</code>
              没有提供参数名，则可使用默认名称
              <code class="language-plaintext highlighter-rouge">newValue</code
              >。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">struct</span> <span class="kt">AlternativeRect</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">origin</span> <span class="o">=</span> <span class="kt">Point</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">size</span> <span class="o">=</span> <span class="kt">Size</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">center</span><span class="p">:</span> <span class="kt">Point</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">centerX</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">let</span> <span class="nv">centerY</span> <span class="o">=</span> <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="kt">Point</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">centerX</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">centerY</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nf">set</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">newCenter</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">size</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">origin</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">newCenter</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">size</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h3 id="属性观察器">属性观察器</h3>

          <ul>
            <li>
              属性观察器（Property
              observer）可以监视存储属性值的变化，分为两种：一种是事先响应的
              <code class="language-plaintext highlighter-rouge">willSet</code
              >，一种是事后响应的
              <code class="language-plaintext highlighter-rouge">didSet</code>。
            </li>
            <li>
              观察器的语法与 getter / setter 类似，<code
                class="language-plaintext highlighter-rouge"
                >willSet</code
              >
              默认参数名为
              <code class="language-plaintext highlighter-rouge">newValue</code
              >，<code class="language-plaintext highlighter-rouge"
                >didSet</code
              >
              默认参数名为
              <code class="language-plaintext highlighter-rouge">oldValue</code
              >。
            </li>
            <li>
              在实例初始化阶段为属性设初值以及 ARC 将弱引用设为
              <code class="language-plaintext highlighter-rouge">nil</code>
              时不会触发属性观察器。
            </li>
          </ul>

          <h3 id="全局和局部变量">全局和局部变量</h3>

          <ul>
            <li>计算属性和属性观察器的语法也可用于全局和局部变量。</li>
            <li>
              全局常量总是<strong>惰性求值</strong>的，而局部变量总是<strong>及早求值</strong>的。
            </li>
          </ul>

          <h3 id="类型属性">类型属性</h3>

          <ul>
            <li>
              前面介绍的属性是实例属性，还有一种特殊的属性叫类型属性（type
              property）。实例属性存储在各个实例中，同一类型的不同实例之间属性值是各自独立的；而类型属性属于类型本身，不管有多少个实例该属性都是一样的。
            </li>
            <li>
              类型属性可使用
              <code class="language-plaintext highlighter-rouge">static</code>
              关键字定义；对于类的计算属性，可将
              <code class="language-plaintext highlighter-rouge">static</code>
              改为
              <code class="language-plaintext highlighter-rouge">class</code>
              以允许子类重写其实现，<code
                class="language-plaintext highlighter-rouge"
                >static</code
              >
              就相当于
              <code class="language-plaintext highlighter-rouge"
                >final class</code
              >。
            </li>
            <li>
              跟全局变量相似，类型属性也是惰性求值的，因此可以方便地创建单例。
            </li>
          </ul>

          <h2 id="方法">方法</h2>

          <h3 id="实例方法">实例方法</h3>

          <ul>
            <li>
              在实例方法中访问属性和方法一般不必显式写出
              <code class="language-plaintext highlighter-rouge">self.</code
              >，除非局部变量与属性重名、在逃逸闭包中访问属性和方法等情况。
            </li>
            <li>
              值类型（结构体和枚举）默认不可以在实例方法中被修改，但可以在实例方法前加上
              <code class="language-plaintext highlighter-rouge">mutating</code>
              关键字，这样便可以修改属性或是直接为
              <code class="language-plaintext highlighter-rouge">self</code>
              赋一个新值，修改后的新实例将会自动取代原实例。对于一个值类型的常量，<code
                class="language-plaintext highlighter-rouge"
                >mutating</code
              >
              方法都是不可调用的。
            </li>
          </ul>

          <h3 id="类型方法">类型方法</h3>

          <ul>
            <li>
              类型方法的机制与类型属性相同，关键字亦为
              <code class="language-plaintext highlighter-rouge">static</code>
              和
              <code class="language-plaintext highlighter-rouge">class</code>。
            </li>
          </ul>

          <h2 id="下标">下标</h2>

          <ul>
            <li>
              可以在类、结构体和枚举中定义下标，即可通过
              <code class="language-plaintext highlighter-rouge">[]</code>
              访问和赋值。
            </li>
            <li>
              下标的语法与 getter 和 setter 类似，只读下标可以省略
              <code class="language-plaintext highlighter-rouge">get</code>
              关键字，<code class="language-plaintext highlighter-rouge"
                >set</code
              >
              默认参数名为
              <code class="language-plaintext highlighter-rouge">newValue</code
              >。
            </li>
            <li>
              下标的参数可以使用可变参数，但不允许输入输出参数或设置参数默认值。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="nf">subscript</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="k">set</span> <span class="p">{</span>
        <span class="n">values</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">newValue</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h2 id="继承">继承</h2>

          <ul>
            <li>
              可以通过
              <code class="language-plaintext highlighter-rouge"
                >class Subclass: Superclass { … }</code
              >
              的语法来实现继承，Swift 不允许多重继承。
            </li>
            <li>
              子类可以使用
              <code class="language-plaintext highlighter-rouge">override</code>
              关键字重写父类的属性、方法和下标，重写版本的方法签名（名称、参数标签、参数类型、返回值类型）应与父类版本完全相同。<sup
                id="fnref:overload"
                role="doc-noteref"
                ><a href="#fn:overload" class="footnote">2</a></sup
              >
              重写时可以通过
              <code class="language-plaintext highlighter-rouge">super</code>
              来访问父类的属性、方法和下标。
            </li>
            <li>
              不论继承来的是存储属性还是计算属性，都可以用一个 getter
              和一个可选的 setter
              来重写。可以将一个继承来的只读属性重写为读写属性，但反过来不行。
            </li>
            <li>
              不论继承来的是存储属性还是计算属性，都可以添加属性观察器。没有必要同时重写
              setter 和添加观察器，因为观察器的代码都可以直接放在 setter 里。
            </li>
            <li>
              属性、方法和下标可以使用
              <code class="language-plaintext highlighter-rouge">final</code>
              关键字防止被重写，也可以在整个类的定义前加
              <code class="language-plaintext highlighter-rouge">final</code>
              使其不可以被继承。
            </li>
          </ul>

          <h2 id="类型转换">类型转换</h2>

          <ul>
            <li>
              类型检查运算符
              <code class="language-plaintext highlighter-rouge">is</code>
              可以检查是否为某类型的实例，抑或是否遵循某协议。
            </li>
            <li>
              类型转换运算符
              <code class="language-plaintext highlighter-rouge">as</code>
              可以进行编译器确保成功的类型转换，譬如从子类到父类的向上转型（upcasting）<sup
                id="fnref:casting"
                role="doc-noteref"
                ><a href="#fn:casting" class="footnote">3</a></sup
              >、指定字面量的类型（如
              <code class="language-plaintext highlighter-rouge"
                >1 as Float</code
              >）、Swift 值类型与 Objective-C 类型的桥接转换（如
              <code class="language-plaintext highlighter-rouge"
                >string as NSString</code
              >）<sup id="fnref:bridging" role="doc-noteref"
                ><a href="#fn:bridging" class="footnote">4</a></sup
              >
              等。
            </li>
            <li>
              对于运行时才能确定是否成功的向下转型（downcasting）<sup
                id="fnref:casting:1"
                role="doc-noteref"
                ><a href="#fn:casting" class="footnote">3</a></sup
              >，可以使用
              <code class="language-plaintext highlighter-rouge">as?</code>
              返回一个可空值或者使用
              <code class="language-plaintext highlighter-rouge">as!</code>
              强制解包。
            </li>
            <li>
              Swift 中有两个特殊的类型：<code
                class="language-plaintext highlighter-rouge"
                >Any</code
              >
              可以表示任何类型（type）的实例，<code
                class="language-plaintext highlighter-rouge"
                >AnyObject</code
              >
              可以表示任何类（class）的实例。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="k">switch</span> <span class="n">thing</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">0</span> <span class="k">as</span> <span class="kt">Int</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"zero as an Int"</span><span class="p">)</span>
<span class="k">case</span> <span class="mi">0</span> <span class="k">as</span> <span class="kt">Double</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"zero as a Double"</span><span class="p">)</span>
<span class="k">case</span> <span class="k">let</span> <span class="nv">someDouble</span> <span class="k">as</span> <span class="kt">Double</span> <span class="k">where</span> <span class="n">someDouble</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"a positive double value of </span><span class="se">\(</span><span class="n">someDouble</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="k">case</span> <span class="k">is</span> <span class="kt">Double</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"some other double value that I don't want to print"</span><span class="p">)</span>
<span class="k">case</span> <span class="k">let</span> <span class="nv">stringConverter</span> <span class="nf">as</span> <span class="p">(</span><span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="nf">stringConverter</span><span class="p">(</span><span class="s">"Michael"</span><span class="p">))</span>
<span class="k">default</span><span class="p">:</span>
   <span class="nf">print</span><span class="p">(</span><span class="s">"something else"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h2 id="构造器">构造器</h2>

          <ul>
            <li>
              对于所有属性均有初值且未自定义构造器的结构体和类，Swift
              会自动生成一个无参的<strong>默认构造器</strong>。而所有未自定义构造器的结构体同时也有一个默认的<strong>成员逐一构造器</strong>（memberwise
              initializer），形如
              <code class="language-plaintext highlighter-rouge"
                >Monitor(width: 2560, height: 1600)</code
              >
              来初始化所有属性。
            </li>
            <li>
              对于初始化过程相对复杂的属性，除了自定义构造器之外，也可以通过一个立即执行的闭包（类似
              JS 中的 IIFE）来赋值，形如
              <code class="language-plaintext highlighter-rouge"
                >let property: T = { return value }()</code
              >。
            </li>
          </ul>

          <h3 id="类的构造规则">类的构造规则</h3>

          <p>
            <img
              src="https://docs.swift.org/swift-book/_images/initializerDelegation01_2x.png"
              alt=""
            />
          </p>

          <ul>
            <li>
              类的构造器分为两种：<strong>指定构造器</strong>（designated
              initializer）是主要的构造器，它负责初始化所有属性并调用父类的构造器以完成构造链，每个类至少拥有一个指定构造器；<strong>便利构造器</strong>（convenience
              initializer）是次要的构造器，它将委托指定构造器完成初始化，需要额外的
              <code class="language-plaintext highlighter-rouge"
                >convenience</code
              >
              关键字标识。
              <ul>
                <li>
                  指定构造器第一步必须保证本类引入的所有属性被初始化，该过程中不能调用任何实例方法、不能读取实例属性的值、也不能引用
                  <code class="language-plaintext highlighter-rouge">self</code
                  >；第二步必须向上调用父类构造器，自底向上完成构造链；第三步的时候实例已经初始化完成了，所以可进行任何自定义操作，这个过程是自顶向下即先父类后子类的。
                </li>
                <li>
                  便利构造器必须先直接或间接调用本类的指定构造器，再进行任何自定义操作。
                </li>
              </ul>
            </li>
            <li>
              无论是把父类的指定构造器重写成子类的指定构造器还是便利构造器，都需要加上
              <code class="language-plaintext highlighter-rouge">override</code>
              关键字。另一方面，根据构造规则子类无法访问父类的便利构造器，因此即使跟父类的便利构造器方法签名相同严格来讲也不算重写，所以不需要加
              <code class="language-plaintext highlighter-rouge">override</code
              >。
            </li>
            <li>
              子类默认不会继承父类的构造器，但有两个例外：
              <ul>
                <li>
                  如果子类没有定义任何指定构造器，它将自动继承父类的所有指定构造器；
                </li>
                <li>
                  如果子类提供了父类所有指定构造器的实现（可通过继承），它将自动继承父类的所有便利构造器。
                </li>
              </ul>
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">class</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
    <span class="kd">convenience</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Anonymous"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="kt">Idol</span><span class="p">:</span> <span class="kt">Person</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">group</span><span class="p">:</span> <span class="kt">String</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">group</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">group</span> <span class="o">=</span> <span class="n">group</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">override</span> <span class="kd">convenience</span> <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="nv">group</span><span class="p">:</span> <span class="s">"Solo"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              使用
              <code class="language-plaintext highlighter-rouge">required</code>
              关键字可以标识一个<strong>必要构造器</strong>，即子类必须实现这个构造器（可通过继承），且不需要加
              <code class="language-plaintext highlighter-rouge">override</code>
              关键字。
            </li>
          </ul>

          <h3 id="可失败构造器">可失败构造器</h3>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">init?</code> 或
              <code class="language-plaintext highlighter-rouge">init!</code>
              可以定义可失败构造器（failable
              initializer），它将创建一个可空值以应对初始化失败的情况。当无法完成初始化时，在构造器内
              <code class="language-plaintext highlighter-rouge"
                >return nil</code
              >
              即可。
            </li>
            <li>
              子类可以将父类的可失败构造器重写为非可失败构造器（对父类构造器创建的可空值强制解包），但反过来不行。
            </li>
          </ul>

          <h2 id="析构器">析构器</h2>

          <ul>
            <li>
              当类的实例释放时如果需要进行额外的清理，可以用
              <code class="language-plaintext highlighter-rouge"
                >deinit { … }</code
              >
              定义一个析构器。
            </li>
            <li>不论子类有没有定义析构器，最后都会自动调用父类的析构器。</li>
          </ul>

          <h2 id="自动引用计数">自动引用计数</h2>

          <ul>
            <li>
              Swift 使用引用计数（reference counting）进行类实例的内存管理，因为
              Objective-C 2.0
              以前需要手动增减计数，所以现在自动化的方式被称为自动引用计数（ARC）。不过相比于追踪式垃圾回收（tracing
              garbage
              collection），引用计数的一大问题在于互相持有引用的对象会形成环从而无法释放，因此
              Swift 引入了强弱引用的概念。
              <ul>
                <li>
                  类实例的赋值默认会建立一个<strong>强引用</strong>，所有引用方式中只有强引用会阻止
                  ARC 释放资源；
                </li>
                <li>
                  在变量声明前加上
                  <code class="language-plaintext highlighter-rouge">weak</code>
                  关键字表示一个<strong>弱引用</strong>，其类型必须是可空类型，当其引用的类实例被释放后会被赋值为
                  <code class="language-plaintext highlighter-rouge">nil</code
                  >；
                </li>
                <li>
                  在变量和常量声明前加上
                  <code class="language-plaintext highlighter-rouge"
                    >unowned</code
                  >
                  关键字表示一个<strong>非持有引用</strong>，它不会被设为
                  <code class="language-plaintext highlighter-rouge">nil</code
                  >，但在其引用的类实例被释放后访问会触发运行时错误。
                </li>
              </ul>
            </li>
            <li>
              当一个类拥有一个闭包类型的属性，且该闭包捕获了该类的实例时，也会形成一个环。为了解决这个问题，我们可以在闭包的参数表前面显式指定捕获列表，譬如
              <code class="language-plaintext highlighter-rouge"
                >[unowned self, weak delegate = self.delegate!]</code
              >。
            </li>
          </ul>

          <h2 id="协议">协议</h2>

          <ul>
            <li>
              协议用于声明其遵循者必须实现的属性、方法、下标、构造器等要求，协议亦可以继承。声明一个子类遵循协议时，应当先写其父类再列出协议，形如
              <code class="language-plaintext highlighter-rouge"
                >class Subclass: Superclass, FirstProtocol,
                AnotherProtocol</code
              >。
              <ul>
                <li>
                  协议中声明的属性只需要指定其读写能力：在声明后加上
                  <code class="language-plaintext highlighter-rouge"
                    >{ get }</code
                  >
                  表示可读，任何属性都能满足要求；<code
                    class="language-plaintext highlighter-rouge"
                    >{ get set }</code
                  >
                  表示可读写，只有变量存储属性和读写计算属性可以满足要求。
                </li>
                <li>
                  如果希望值类型也能顺利遵循协议，则应在所有可能对实例进行修改的方法要求前加上
                  <code class="language-plaintext highlighter-rouge"
                    >mutating</code
                  >
                  关键字，而引用类型不受此限制。
                </li>
                <li>
                  非
                  <code class="language-plaintext highlighter-rouge"
                    >final</code
                  >
                  类在实现构造器要求时，需要将其标识为
                  <code class="language-plaintext highlighter-rouge"
                    >required</code
                  >。
                </li>
              </ul>
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">protocol</span> <span class="kt">Togglable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">toggle</span><span class="p">()</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              如果不希望结构体或枚举遵循协议，可以让该协议继承于
              <code class="language-plaintext highlighter-rouge">AnyObject</code
              >。
            </li>
            <li>
              将协议作为类型使用时，可以用
              <code class="language-plaintext highlighter-rouge">&amp;</code>
              来组合多个协议表示这些都遵循的类型。<sup
                id="fnref:composition"
                role="doc-noteref"
                ><a href="#fn:composition" class="footnote">5</a></sup
              >
            </li>
            <li>
              为了与 Objective-C 兼容，Swift
              还可以声明可选要求，此时协议及其可选要求都必须以
              <code class="language-plaintext highlighter-rouge">@objc</code>
              修饰，且这样的协议只能被
              <code class="language-plaintext highlighter-rouge">@objc</code>
              类（包括继承于 Objective-C 类的类）遵循。<sup
                id="fnref:optional"
                role="doc-noteref"
                ><a href="#fn:optional" class="footnote">6</a></sup
              >
              协议的可选要求用
              <code class="language-plaintext highlighter-rouge">optional</code>
              关键字标识，若应用于方法要求则方法类型本身是可空类型，即
              <code class="language-plaintext highlighter-rouge"
                >((T) -&gt; T)?</code
              >，调用这个方法时应在方法名和括号之间加
              <code class="language-plaintext highlighter-rouge">?</code> 或
              <code class="language-plaintext highlighter-rouge">!</code>。
            </li>
          </ul>

          <h2 id="扩展">扩展</h2>

          <ul>
            <li>
              Swift 的扩展（extension）与Objective-C
              中的分类（category）类似，可以向一个已有的类、结构体和枚举添加新的功能，但扩展不能重写已有的功能。
              <ul>
                <li>
                  扩展可以添加计算属性，但不可以添加存储属性或向已有属性添加观察器。
                </li>
                <li>
                  对于已有的类，扩展可以添加新的便利构造器，但不可以添加指定构造器和析构器。
                </li>
                <li>
                  对于结构体，因为一旦自定义构造器就得不到默认的成员逐一构造器，因此可以把所有自定义构造器都挪到扩展中。
                </li>
                <li>
                  用
                  <code class="language-plaintext highlighter-rouge"
                    >extension Type: Protocol { … }</code
                  >
                  语法可以扩展
                  <code class="language-plaintext highlighter-rouge">Type</code>
                  遵循
                  <code class="language-plaintext highlighter-rouge"
                    >Protocol</code
                  >
                  协议，这经常用于拆分一个类型对多个协议的实现，让代码更具可读性。
                </li>
                <li>
                  另外，扩展也可以添加新的实例方法、类型方法、下标、嵌套类型。
                </li>
              </ul>
            </li>
            <li>
              <strong>协议扩展</strong
              >是对一个已有的协议进行扩展，既可以为遵循该协议的类型添加计算属性、方法、下标、构造器的实现，也可以为已有的协议要求提供默认实现。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">extension</span> <span class="kt">Collection</span> <span class="k">where</span> <span class="kt">Element</span><span class="p">:</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">allEqual</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">reduce</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span> <span class="nv">$0</span> <span class="o">&amp;&amp;</span> <span class="nv">$1</span> <span class="o">==</span> <span class="n">first</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h2 id="泛型">泛型</h2>

          <ul>
            <li>
              在函数和类型名称后加上类型参数
              <code class="language-plaintext highlighter-rouge"
                >&lt;T&gt;</code
              >
              可以定义泛型函数和泛型类型，亦可以在此基础上添加<strong>类型约束</strong>，如
              <code class="language-plaintext highlighter-rouge"
                >&lt;T: SomeClass, U: SomeProtocol&gt;</code
              >。
            </li>
            <li>
              协议有时也需要类似的泛型特性，为此我们可以使用<strong>关联类型</strong>（associated
              type），这些占位符的实际类型会在其遵循者实现协议要求时自动推断出来。
            </li>
            <li>
              与泛型的类型约束类似，关联类型可以使用<strong
                >泛型
                <code class="language-plaintext highlighter-rouge">where</code>
                从句</strong
              >（generic
              <code class="language-plaintext highlighter-rouge">where</code>
              clause）进行约束，可以指定关联类型应遵循什么协议，或者与其他什么类型相同。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">protocol</span> <span class="kt">Container</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="kt">Item</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">append</span><span class="p">(</span><span class="n">_</span> <span class="nv">item</span><span class="p">:</span> <span class="kt">Item</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
    <span class="nf">subscript</span><span class="p">(</span><span class="nv">i</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Item</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="kd">associatedtype</span> <span class="kt">Iterator</span><span class="p">:</span> <span class="kt">IteratorProtocol</span> <span class="k">where</span> <span class="kt">Iterator</span><span class="o">.</span><span class="kt">Element</span> <span class="o">==</span> <span class="kt">Item</span>
    <span class="kd">func</span> <span class="nf">makeIterator</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Iterator</span>
<span class="p">}</span>
<span class="kd">protocol</span> <span class="kt">ComparableContainer</span><span class="p">:</span> <span class="kt">Container</span> <span class="k">where</span> <span class="kt">Item</span><span class="p">:</span> <span class="kt">Comparable</span> <span class="p">{}</span>
</code></pre>
            </div>
          </div>

          <h2 id="错误处理">错误处理</h2>

          <ul>
            <li>
              错误处理在 Swift 中拥有语言层面的支持
              <sup id="fnref:error" role="doc-noteref"
                ><a href="#fn:error" class="footnote">7</a></sup
              >，不过与其他语言不同的是 Swift 错误处理的实现并非栈回退（stack
              unwinding）<sup id="fnref:unwinding" role="doc-noteref"
                ><a href="#fn:unwinding" class="footnote">8</a></sup
              >，因此其开销相对较小。
            </li>
            <li>
              Swift 中的错误用遵循
              <code class="language-plaintext highlighter-rouge">Error</code>
              协议的对象表示，通常会使用枚举类型，抛出则用
              <code class="language-plaintext highlighter-rouge">throw</code>
              语句。
            </li>
            <li>
              Swift 中有 4 种处理错误的方式：将错误传播到调用本函数的代码、用
              <code class="language-plaintext highlighter-rouge">do-catch</code>
              处理错误、将错误视为可空值、断定错误不会发生。因为抛出错误会改变程序的流程，所以应该在所有可能抛出错误的函数、方法和构造器的调用前加上
              <code class="language-plaintext highlighter-rouge">try</code>
              关键字。
              <ul>
                <li>
                  对于一个会传播错误的函数，需要在参数列表和返回值的箭头之间加上
                  <code class="language-plaintext highlighter-rouge"
                    >throws</code
                  >
                  关键字，这样才能在函数中自由使用
                  <code class="language-plaintext highlighter-rouge"
                    >throw</code
                  >
                  和
                  <code class="language-plaintext highlighter-rouge">try</code
                  >。
                </li>
                <li>
                  用
                  <code class="language-plaintext highlighter-rouge"
                    >do-catch</code
                  >
                  语句可以处理一大块代码的错误，<code
                    class="language-plaintext highlighter-rouge"
                    >catch</code
                  >
                  对错误的捕获类似模式匹配，默认分支的错误对象将绑定到
                  <code class="language-plaintext highlighter-rouge">error</code
                  >，未匹配的错误将继续向外传播。错误一旦抛出，<code
                    class="language-plaintext highlighter-rouge"
                    >do</code
                  >
                  中剩下的代码将不再执行，<code
                    class="language-plaintext highlighter-rouge"
                    >catch</code
                  >
                  捕获并处理完错误后接着执行整个
                  <code class="language-plaintext highlighter-rouge"
                    >do-catch</code
                  >
                  后面的代码。
                </li>
                <li>
                  将
                  <code class="language-plaintext highlighter-rouge">try</code>
                  替换为
                  <code class="language-plaintext highlighter-rouge">try?</code>
                  可将结果转换成可空值，一旦出错则结果为
                  <code class="language-plaintext highlighter-rouge">nil</code
                  >。
                </li>
                <li>
                  将
                  <code class="language-plaintext highlighter-rouge">try</code>
                  替换为
                  <code class="language-plaintext highlighter-rouge">try!</code>
                  可以无视错误强制执行，一旦出错将触发运行时错误。
                </li>
              </ul>
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="k">do</span> <span class="p">{</span>
    <span class="k">try</span> <span class="nf">shakeHands</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"Nanase Nishino"</span><span class="p">,</span> <span class="nv">in</span><span class="p">:</span> <span class="s">"Nogizaka46"</span><span class="p">)</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"I have just shaken hands with my favorite idol!"</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">HandshakeError</span><span class="o">.</span><span class="n">noTicket</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"You do not have a handshake ticket."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="kt">HandshakeError</span><span class="o">.</span><span class="nf">incorrectGroup</span><span class="p">(</span><span class="k">let</span> <span class="nv">correctGroup</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"The group you specify is incorrect. She is a member of </span><span class="se">\(</span><span class="n">correctGroup</span><span class="se">)</span><span class="s"> instead."</span><span class="p">)</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"Unexpected error: </span><span class="se">\(</span><span class="n">error</span><span class="se">)</span><span class="s">."</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              使用
              <code class="language-plaintext highlighter-rouge">defer</code>
              语句可以确保在离开当前代码块前执行特定的清理操作，包括抛出错误或是
              <code class="language-plaintext highlighter-rouge">return</code> /
              <code class="language-plaintext highlighter-rouge">break</code>
              的情况。如果一个代码块有多个
              <code class="language-plaintext highlighter-rouge">defer</code>
              语句，则它们最后会被逆序执行。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">func</span> <span class="nf">processFile</span><span class="p">(</span><span class="n">_</span> <span class="nv">filename</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nf">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">file</span> <span class="o">=</span> <span class="nf">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">defer</span> <span class="p">{</span>
            <span class="nf">close</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nv">line</span> <span class="o">=</span> <span class="k">try</span> <span class="n">file</span><span class="o">.</span><span class="nf">readline</span><span class="p">()</span> <span class="p">{</span>
            <span class="c1">// Work with the file.</span>
        <span class="p">}</span>
        <span class="c1">// `close(file)` is called here, at the end of the scope.</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h3 id="断言">断言</h3>

          <ul>
            <li>
              在调试中我们常常希望检查某些条件是否成立，但又没有必要为此抛出错误，这时我们可以使用断言。断言函数的代码只会在
              <code class="language-plaintext highlighter-rouge">Debug</code>
              编译配置下执行，其签名如下：
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">func</span> <span class="nf">assert</span><span class="p">(</span><span class="n">_</span> <span class="nv">condition</span><span class="p">:</span> <span class="kd">@autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">,</span>
              <span class="n">_</span> <span class="nv">message</span><span class="p">:</span> <span class="kd">@autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(),</span>
                   <span class="nv">file</span><span class="p">:</span> <span class="kt">StaticString</span> <span class="o">=</span> <span class="kd">#file</span><span class="p">,</span>
                   <span class="nv">line</span><span class="p">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="kd">#line</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              其中
              <code class="language-plaintext highlighter-rouge"
                >@autoclosure</code
              >
              能够将一句表达式自动包装成一个无参的闭包，使用该特性能够延迟表达式（即闭包返回值）的计算，譬如
              <code class="language-plaintext highlighter-rouge">Release</code>
              编译配置下就不会进行计算。<sup
                id="fnref:autoclosure"
                role="doc-noteref"
                ><a href="#fn:autoclosure" class="footnote">9</a></sup
              >
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">#file</code> /
              <code class="language-plaintext highlighter-rouge">#line</code>
              相当于 C 语言中的宏
              <code class="language-plaintext highlighter-rouge">__FILE__</code>
              /
              <code class="language-plaintext highlighter-rouge">__LINE__</code
              >，其名始于 Swift 2.2（<a
                href="https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md"
                >SE-0028</a
              >）。
            </li>
          </ul>

          <h3 id="致命错误">致命错误</h3>

          <ul>
            <li>
              如果在某些场景下
              <sup id="fnref:fatalerror" role="doc-noteref"
                ><a href="#fn:fatalerror" class="footnote">10</a></sup
              >
              遇到不可恢复的错误需要立即中止程序，我们可以使用
              <code class="language-plaintext highlighter-rouge"
                >fatalError</code
              >
              函数，其签名如下：
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">func</span> <span class="nf">fatalError</span><span class="p">(</span><span class="n">_</span> <span class="nv">message</span><span class="p">:</span> <span class="kd">@autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(),</span>
                     <span class="nv">file</span><span class="p">:</span> <span class="kt">StaticString</span> <span class="o">=</span> <span class="kd">#file</span><span class="p">,</span>
                     <span class="nv">line</span><span class="p">:</span> <span class="kt">UInt</span> <span class="o">=</span> <span class="kd">#line</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Never</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              返回类型
              <code class="language-plaintext highlighter-rouge">Never</code>
              表示这个函数一定不会正常返回，Swift 3.0（<a
                href="https://github.com/apple/swift-evolution/blob/master/proposals/0102-noreturn-bottom-type.md"
                >SE-0102</a
              >）之前是在函数上用
              <code class="language-plaintext highlighter-rouge"
                >@noreturn</code
              >
              来标识。
            </li>
          </ul>

          <h2 id="访问控制">访问控制</h2>

          <ul>
            <li>
              Swift
              的访问控制模型基于<strong>模块</strong>和<strong>源文件</strong>两个概念，其中模块是指代码分发的独立单元，如一款应用或一个框架。Swift
              目前共有 5 种访问级别，从高（宽松）到低（严格）分别为：<sup
                id="fnref:levels"
                role="doc-noteref"
                ><a href="#fn:levels" class="footnote">11</a></sup
              >
              <ul>
                <li>
                  <code class="language-plaintext highlighter-rouge">open</code>
                  表示可以被任何模块的源文件访问，并可以在任何地方被继承和重写，只适用于类和可被重写的类成员。
                </li>
                <li>
                  <code class="language-plaintext highlighter-rouge"
                    >public</code
                  >
                  表示可以被任何模块的源文件访问，但只能在本模块内被继承和重写。
                </li>
                <li>
                  <code class="language-plaintext highlighter-rouge"
                    >internal</code
                  >
                  表示只能被本模块内的源文件访问，这是<strong>默认访问级别</strong>。
                </li>
                <li>
                  <code class="language-plaintext highlighter-rouge"
                    >fileprivate</code
                  >
                  表示只在当前源文件中可见。
                </li>
                <li>
                  <code class="language-plaintext highlighter-rouge"
                    >private</code
                  >
                  表示只在其外层声明和当前源文件中该声明的扩展内可见。
                </li>
              </ul>
            </li>
            <li>
              Swift
              的访问级别遵循一个基本原则：一个实体不能基于更低访问级别的实体来定义，譬如变量自身的访问级别不能高于其类型、函数的访问级别不能高于其参数或返回值的类型等等。另外有一些规则需要特别注意：
              <ul>
                <li>
                  自定义类的成员的访问级别默认与类相同，但
                  <code class="language-plaintext highlighter-rouge">open</code>
                  /
                  <code class="language-plaintext highlighter-rouge"
                    >public</code
                  >
                  类的成员默认还是
                  <code class="language-plaintext highlighter-rouge"
                    >internal</code
                  >
                  级别，以防公开 API 的内部接口也被默认公开。
                </li>
                <li>
                  子类的访问级别不得高于父类，但子类重写的成员可以拥有比父类版本更高的访问级别。
                </li>
              </ul>
            </li>
            <li>
              可以为 setter 指定比 getter 更低的访问级别，譬如
              <code class="language-plaintext highlighter-rouge"
                >public private(set) var</code
              >。
            </li>
            <li>
              只要在被测试模块的编译选项中开启测试，并使用
              <code class="language-plaintext highlighter-rouge"
                >@testable import</code
              >
              来导入模块，则可以在单元测试中访问所有
              <code class="language-plaintext highlighter-rouge">internal</code>
              级别的实体。
            </li>
          </ul>

          <h2 id="运算符">运算符</h2>

          <table>
            <thead>
              <tr>
                <th>Operator</th>
                <th>Associativity</th>
                <th>Precedence Group</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">!</code>
                  <code class="language-plaintext highlighter-rouge">~</code>
                  <code class="language-plaintext highlighter-rouge">+</code>
                  <code class="language-plaintext highlighter-rouge">-</code>
                </td>
                <td>-</td>
                <td>(prefix)</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >&lt;&lt;</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >&gt;&gt;</code
                  >
                </td>
                <td>-</td>
                <td>BitwiseShift</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">*</code>
                  <code class="language-plaintext highlighter-rouge">/</code>
                  <code class="language-plaintext highlighter-rouge">%</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;*</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;</code
                  >
                </td>
                <td>Left</td>
                <td>Multiplication</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">+</code>
                  <code class="language-plaintext highlighter-rouge">-</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;+</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;-</code
                  >
                  <code class="language-plaintext highlighter-rouge">|</code>
                  <code class="language-plaintext highlighter-rouge">^</code>
                </td>
                <td>Left</td>
                <td>Addition</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >..&lt;</code
                  >
                  <code class="language-plaintext highlighter-rouge">...</code>
                </td>
                <td>-</td>
                <td>RangeFormation</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">is</code>
                  <code class="language-plaintext highlighter-rouge">as</code>
                  <code class="language-plaintext highlighter-rouge">as?</code>
                  <code class="language-plaintext highlighter-rouge">as!</code>
                </td>
                <td>Left</td>
                <td>Casting</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">??</code>
                </td>
                <td>Right</td>
                <td>NilCoalescing</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">&lt;</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&lt;=</code
                  >
                  <code class="language-plaintext highlighter-rouge">&gt;</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&gt;=</code
                  >
                  <code class="language-plaintext highlighter-rouge">==</code>
                  <code class="language-plaintext highlighter-rouge">!=</code>
                  <code class="language-plaintext highlighter-rouge">===</code>
                  <code class="language-plaintext highlighter-rouge">!==</code>
                  <code class="language-plaintext highlighter-rouge">~=</code>
                </td>
                <td>-</td>
                <td>Comparison</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;&amp;</code
                  >
                </td>
                <td>Left</td>
                <td>LogicalConjunction</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">||</code>
                </td>
                <td>Left</td>
                <td>LogicalDisjunction</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">?:</code>
                </td>
                <td>Right</td>
                <td>Ternary</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">=</code>
                  <code class="language-plaintext highlighter-rouge">*=</code>
                  <code class="language-plaintext highlighter-rouge">/=</code>
                  <code class="language-plaintext highlighter-rouge">%=</code>
                  <code class="language-plaintext highlighter-rouge">+=</code>
                  <code class="language-plaintext highlighter-rouge">-=</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&lt;&lt;=</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >&gt;&gt;=</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;=</code
                  >
                  <code class="language-plaintext highlighter-rouge">|=</code>
                  <code class="language-plaintext highlighter-rouge">^=</code>
                </td>
                <td>Right</td>
                <td>Assignment</td>
              </tr>
            </tbody>
          </table>

          <h3 id="运算符重载">运算符重载</h3>

          <ul>
            <li>
              双目运算符，或称中置运算符，实现的语法与普通函数或类型方法相同。<sup
                id="fnref:operator"
                role="doc-noteref"
                ><a href="#fn:operator" class="footnote">12</a></sup
              >
            </li>
            <li>
              单目运算符分为前置运算符和后置运算符，分别表示为
              <code class="language-plaintext highlighter-rouge"
                >prefix func</code
              >
              和
              <code class="language-plaintext highlighter-rouge"
                >postfix func</code
              >。
            </li>
            <li>
              现有运算符中
              <code class="language-plaintext highlighter-rouge">=</code> 和
              <code class="language-plaintext highlighter-rouge">?:</code>
              不可被重载，另外复合赋值运算符的第一个参数应为
              <code class="language-plaintext highlighter-rouge">inout</code>。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kd">extension</span> <span class="kt">Vector2D</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="o">+</span> <span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="kt">Vector2D</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Vector2D</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Vector2D</span><span class="p">(</span><span class="nv">x</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nv">y</span><span class="p">:</span> <span class="n">left</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h3 id="自定义运算符">自定义运算符</h3>

          <ul>
            <li>
              对于尚不存在的运算符，在实现之前需要首先进行声明，语法为
              <code class="language-plaintext highlighter-rouge"
                >{in,pre,post}fix operator ×: PrecedenceGroup</code
              >。
            </li>
            <li>
              双目运算符的优先级和结合性都是由其声明的优先级组决定的，若不指定则优先级组默认为
              <code class="language-plaintext highlighter-rouge"
                >DefaultPrecedence</code
              >，这个组的优先级仅高于三目运算符，且没有结合性。<sup
                id="fnref:precedence"
                role="doc-noteref"
                ><a href="#fn:precedence" class="footnote">13</a></sup
              >
            </li>
            <li>
              单目运算符没有优先级组的概念，优先级：后置 &gt; 前置 &gt; 中置。
            </li>
          </ul>

          <div class="language-swift highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="k">precedencegroup</span> <span class="kt">ExponentiationPrecedence</span> <span class="p">{</span>
    <span class="nv">associativity</span><span class="p">:</span> <span class="n">right</span>
    <span class="nv">higherThan</span><span class="p">:</span> <span class="kt">MultiplicationPrecedence</span>
<span class="p">}</span>
<span class="k">infix</span> <span class="k">operator</span> <span class="o">**</span><span class="p">:</span> <span class="kt">ExponentiationPrecedence</span>
<span class="kd">extension</span> <span class="kt">Double</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="o">**</span> <span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nf">pow</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <blockquote>
            <p>
              <strong>&lt;Prev&gt;</strong>
              <a href="/swift-notes-1/">Swift 学习笔记（一）</a><br />
              <strong>&lt;Next&gt;</strong>
              <a href="/swift-notes-3/">Swift 学习笔记（三）</a>
            </p>
          </blockquote>
          <div class="footnotes" role="doc-endnotes">
            <ol>
              <li id="fn:valuetype" role="doc-endnote">
                <p>
                  对结构体和值类型的进一步讨论可以参见
                  <a href="http://objccn.io/issue-16-2/">ObjC 中国</a
                  >，对于是选用结构体还是类可以参见
                  <a
                    href="https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes"
                    >官方文档</a
                  >（优先选用结构体）。 <a
                    href="#fnref:valuetype"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:overload" role="doc-endnote">
                <p>
                  重写（override）不是重载（overload），重载的方法仅名称和参数标签相同，通过参数类型进行重载决议，不需要用关键字标识，跟继承也没有必然联系。 <a
                    href="#fnref:overload"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:casting" role="doc-endnote">
                <p>
                  这里的类型转换（casting）与形如
                  <code class="language-plaintext highlighter-rouge"
                    >Int(3.14)</code
                  >
                  的类型转换（conversion）不同：前者只是向编译器重新描述了原对象的类型，而后者是依赖于构造器生成了一个新的对象。 <a
                    href="#fnref:casting"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  > <a
                    href="#fnref:casting:1"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;<sup>2</sup></a
                  >
                </p>
              </li>
              <li id="fn:bridging" role="doc-endnote">
                <p>
                  在 Swift 3.0（<a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0072-eliminate-implicit-bridging-conversions.md"
                    >SE-0072</a
                  >）之前，这种桥接转换是隐式进行的，不需要
                  <code class="language-plaintext highlighter-rouge">as</code
                  >。 <a
                    href="#fnref:bridging"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:composition" role="doc-endnote">
                <p>
                  在 Swift 3.0（<a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0095-any-as-existential.md"
                    >SE-0095</a
                  >）之前，这被表示为
                  <code class="language-plaintext highlighter-rouge"
                    >protocol&lt;P1, P2&gt;</code
                  >。 <a
                    href="#fnref:composition"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:optional" role="doc-endnote">
                <p>
                  如
                  <a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md"
                    >SE-0070</a
                  >
                  所述，可选要求能被两种 Swift
                  已有的特性取代：一是通过协议扩展来提供某些要求的默认实现，二是通过协议继承把某些要求拆分到另一个协议里去。因此保留可选要求只是为了与
                  Objective-C 兼容。 <a
                    href="#fnref:optional"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:error" role="doc-endnote">
                <p>
                  Swift 2.0 以前的语法还不支持错误处理，对错误的处理跟
                  Objective-C 一样是传入
                  <code class="language-plaintext highlighter-rouge"
                    >NSError</code
                  >
                  对象指针作为输出参数来进行的，相关讨论可以参见
                  <a href="https://swifter.tips/error-handle/">Swifter.tips</a
                  >。 <a
                    href="#fnref:error"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:unwinding" role="doc-endnote">
                <p>
                  Swift 错误处理的实现被称为隐式手动传播（implicit manual
                  propagation），即由编译器生成手动传播错误（如 POSIX
                  的错误码、Objective-C
                  的错误参数等方式）的代码，对此的进一步讨论可以参见
                  <a
                    href="https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#implementation-design"
                    >官方文档</a
                  >。 <a
                    href="#fnref:unwinding"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:autoclosure" role="doc-endnote">
                <p>
                  <a href="https://developer.apple.com/swift/blog/?id=4"
                    >Building assert() in Swift, Part 1: Lazy Evaluation — Swift
                    Blog, Apple Developer</a
                  > <a
                    href="#fnref:autoclosure"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:fatalerror" role="doc-endnote">
                <p>
                  <a href="http://swifter.tips/fatalerror/"
                    >fatalError — Swifter.tips</a
                  > <a
                    href="#fnref:fatalerror"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:levels" role="doc-endnote">
                <p>
                  Swift 一开始只有 3 种访问级别：<code
                    class="language-plaintext highlighter-rouge"
                    >public</code
                  >
                  /
                  <code class="language-plaintext highlighter-rouge"
                    >internal</code
                  >
                  /
                  <code class="language-plaintext highlighter-rouge"
                    >private</code
                  >，其中
                  <code class="language-plaintext highlighter-rouge"
                    >public</code
                  >
                  与现在的
                  <code class="language-plaintext highlighter-rouge">open</code>
                  含义相同，<code class="language-plaintext highlighter-rouge"
                    >private</code
                  >
                  与现在的
                  <code class="language-plaintext highlighter-rouge"
                    >fileprivate</code
                  >
                  含义相同。Swift 3.0 时
                  <a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md"
                    >SE-0117</a
                  >
                  和
                  <a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md"
                    >SE-0025</a
                  >
                  分别引入了
                  <code class="language-plaintext highlighter-rouge">open</code>
                  和
                  <code class="language-plaintext highlighter-rouge"
                    >fileprivate</code
                  >，Swift 4.0 时
                  <a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0169-improve-interaction-between-private-declarations-and-extensions.md"
                    >SE-0169</a
                  >
                  将
                  <code class="language-plaintext highlighter-rouge"
                    >private</code
                  >
                  的可见范围延伸到了扩展。 <a
                    href="#fnref:levels"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:operator" role="doc-endnote">
                <p>
                  从 Swift 3.0（<a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md"
                    >SE-0091</a
                  >）开始，运算符不仅可以被定义为全局函数，还可以是类型方法，且后者更为提倡。 <a
                    href="#fnref:operator"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
              <li id="fn:precedence" role="doc-endnote">
                <p>
                  在 Swift 3.0（<a
                    href="https://github.com/apple/swift-evolution/blob/master/proposals/0077-operator-precedence.md"
                    >SE-0077</a
                  >）之前，运算符优先级是用整数表示的，譬如默认优先级是三目运算符的
                  <code class="language-plaintext highlighter-rouge">100</code
                  >。例程中的
                  <code class="language-plaintext highlighter-rouge">**</code>
                  运算符，按照原来的语法会声明为
                  <code class="language-plaintext highlighter-rouge"
                    >infix operator ** { precedence 160 associativity right
                    }</code
                  >。 <a
                    href="#fnref:precedence"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
            </ol>
          </div>
        </div>

        <div class="comments">
          <div id="disqus_thread"></div>
          <script>
            var disqus_config = function () {
              this.page.url = "https://blog.yzsun.me/swift-notes-2/";
              this.page.identifier = "/swift-notes-2/";
            };
            (function () {
              var d = document,
                s = d.createElement("script");
              s.src = "//yzyzsun.disqus.com/embed.js";
              s.setAttribute("data-timestamp", +new Date());
              (d.head || d.body).appendChild(s);
            })();
          </script>
          <noscript
            >Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript"
              >comments powered by Disqus.</a
            ></noscript
          >
        </div>
      </article>
    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <a href="https://github.com/yzyzsun"
            ><i class="svg-icon github"></i
          ></a>

          <a href="/feed.xml"><i class="svg-icon rss"></i></a>
        </footer>
      </div>
    </div>

    <!-- Google Analytics -->
    <script>
      (function (i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r;
        (i[r] =
          i[r] ||
          function () {
            (i[r].q = i[r].q || []).push(arguments);
          }),
          (i[r].l = 1 * new Date());
        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      );

      ga("create", "UA-65994616-1", "auto");
      ga("send", "pageview", {
        page: "/swift-notes-2/",
        title: "Swift 学习笔记（二）",
      });
    </script>
    <!-- End Google Analytics -->
  </body>
</html>
