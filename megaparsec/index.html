<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <title>Megaparsec: Haskell 的语法分析组合子 | 孙耀珠的博客</title>

    <meta charset="utf-8" />
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <meta
      name="google-site-verification"
      content="zYt2wigM41vmyHtpvOvLHk4Yetcfbv5Bz9pdvsTRT3Y"
    />

    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <meta name="generator" content="Jekyll v4.2.0" />
    <meta property="og:title" content="Megaparsec: Haskell 的语法分析组合子" />
    <meta name="author" content="Mark Karpov" />
    <meta property="og:locale" content="en_US" />
    <meta
      name="description"
      content="原文标题：Megaparsec tutorial from IH book 原文链接：https://markkarpov.com/tutorial/megaparsec.html"
    />
    <meta
      property="og:description"
      content="原文标题：Megaparsec tutorial from IH book 原文链接：https://markkarpov.com/tutorial/megaparsec.html"
    />
    <link rel="canonical" href="https://blog.yzsun.me/megaparsec/" />
    <meta property="og:url" content="https://blog.yzsun.me/megaparsec/" />
    <meta property="og:site_name" content="孙耀珠的博客" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2019-11-24T00:00:00+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta
      property="twitter:title"
      content="Megaparsec: Haskell 的语法分析组合子"
    />
    <script type="application/ld+json">
      {
        "description": "原文标题：Megaparsec tutorial from IH book 原文链接：https://markkarpov.com/tutorial/megaparsec.html",
        "url": "https://blog.yzsun.me/megaparsec/",
        "@type": "BlogPosting",
        "headline": "Megaparsec: Haskell 的语法分析组合子",
        "dateModified": "2019-11-24T00:00:00+00:00",
        "datePublished": "2019-11-24T00:00:00+00:00",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.yzsun.me/megaparsec/"
        },
        "author": { "@type": "Person", "name": "Mark Karpov" },
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.yzsun.me/feed.xml"
      title="孙耀珠的博客"
    />

    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="/style.css" />
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"
            ><img src="/images/avatar.jpg" alt="avatar"
          /></a>

          <div class="site-info">
            <h1 class="site-domain"><a href="/">yzsun.me</a></h1>
            <p class="site-name">孙耀珠的博客</p>
          </div>

          <nav>
            <a href="/">首页</a>
            <a href="/archive/">归档</a>
            <a href="/about/">关于</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
        <h1>Megaparsec: Haskell 的语法分析组合子</h1>

        <div class="info">
          <span>
            <i class="fa fa-calendar"></i>
            2019-11-24
          </span>
          <span>
            <i class="fa fa-user"></i>
            Mark Karpov
          </span>
          <span>
            <i class="fa fa-tags"></i>
            译文
          </span>
        </div>

        <div class="entry">
          <blockquote>
            <p>
              原文标题：Megaparsec tutorial from IH book<br />
              原文链接：<a
                href="https://markkarpov.com/tutorial/megaparsec.html"
                >https://markkarpov.com/tutorial/megaparsec.html</a
              >
            </p>
          </blockquote>

          <!--more-->

          <p>
            本篇 Megaparsec 教程原本是为《<a
              href="https://intermediatehaskell.com/"
              >中级 Haskell</a
            >》一书写的一章。但由于这本书在过去的一年里没有什么进展，于是其他合著者同意将本文发表为一篇独立的教程，以飨读者。
          </p>

          <ul id="markdown-toc">
            <li>
              <a
                href="#parsect-和-parsec-单子"
                id="markdown-toc-parsect-和-parsec-单子"
                ><code class="language-plaintext highlighter-rouge"
                  >ParsecT</code
                >
                和
                <code class="language-plaintext highlighter-rouge">Parsec</code>
                单子</a
              >
            </li>
            <li>
              <a href="#字符和二进制流" id="markdown-toc-字符和二进制流"
                >字符和二进制流</a
              >
            </li>
            <li>
              <a
                href="#单子式和可应用函子式语法"
                id="markdown-toc-单子式和可应用函子式语法"
                >单子式和可应用函子式语法</a
              >
            </li>
            <li>
              <a href="#用-eof-耗尽输入" id="markdown-toc-用-eof-耗尽输入"
                >用
                <code class="language-plaintext highlighter-rouge">eof</code>
                耗尽输入</a
              >
            </li>
            <li>
              <a href="#处理多种选择" id="markdown-toc-处理多种选择"
                >处理多种选择</a
              >
            </li>
            <li>
              <a href="#用-try-控制回溯" id="markdown-toc-用-try-控制回溯"
                >用
                <code class="language-plaintext highlighter-rouge">try</code>
                控制回溯</a
              >
            </li>
            <li>
              <a href="#调试语法分析器" id="markdown-toc-调试语法分析器"
                >调试语法分析器</a
              >
            </li>
            <li>
              <a href="#标签和隐藏" id="markdown-toc-标签和隐藏">标签和隐藏</a>
            </li>
            <li>
              <a href="#运行语法分析器" id="markdown-toc-运行语法分析器"
                >运行语法分析器</a
              >
            </li>
            <li>
              <a href="#monadparsec-类型类" id="markdown-toc-monadparsec-类型类"
                ><code class="language-plaintext highlighter-rouge"
                  >MonadParsec</code
                >
                类型类</a
              >
            </li>
            <li>
              <a href="#词法分析" id="markdown-toc-词法分析">词法分析</a>
              <ul>
                <li><a href="#空格" id="markdown-toc-空格">空格</a></li>
                <li>
                  <a
                    href="#字符和字符串字面量"
                    id="markdown-toc-字符和字符串字面量"
                    >字符和字符串字面量</a
                  >
                </li>
                <li><a href="#数字" id="markdown-toc-数字">数字</a></li>
              </ul>
            </li>
            <li>
              <a
                href="#notfollowedby-和-lookahead"
                id="markdown-toc-notfollowedby-和-lookahead"
                ><code class="language-plaintext highlighter-rouge"
                  >notFollowedBy</code
                >
                和
                <code class="language-plaintext highlighter-rouge"
                  >lookAhead</code
                ></a
              >
            </li>
            <li>
              <a href="#表达式的语法分析" id="markdown-toc-表达式的语法分析"
                >表达式的语法分析</a
              >
            </li>
            <li>
              <a href="#缩进敏感的语法分析" id="markdown-toc-缩进敏感的语法分析"
                >缩进敏感的语法分析</a
              >
              <ul>
                <li>
                  <a
                    href="#nonindented-和-indentblock"
                    id="markdown-toc-nonindented-和-indentblock"
                    ><code class="language-plaintext highlighter-rouge"
                      >nonIndented</code
                    >
                    和
                    <code class="language-plaintext highlighter-rouge"
                      >indentBlock</code
                    ></a
                  >
                </li>
                <li>
                  <a href="#简单的缩进列表" id="markdown-toc-简单的缩进列表"
                    >简单的缩进列表</a
                  >
                </li>
                <li>
                  <a href="#嵌套缩进列表" id="markdown-toc-嵌套缩进列表"
                    >嵌套缩进列表</a
                  >
                </li>
                <li>
                  <a href="#加入折行" id="markdown-toc-加入折行">加入折行</a>
                </li>
              </ul>
            </li>
            <li>
              <a
                href="#编写高效的语法分析器"
                id="markdown-toc-编写高效的语法分析器"
                >编写高效的语法分析器</a
              >
            </li>
            <li>
              <a href="#语法分析错误" id="markdown-toc-语法分析错误"
                >语法分析错误</a
              >
              <ul>
                <li>
                  <a href="#错误的定义" id="markdown-toc-错误的定义"
                    >错误的定义</a
                  >
                </li>
                <li>
                  <a href="#如何触发错误" id="markdown-toc-如何触发错误"
                    >如何触发错误</a
                  >
                </li>
                <li>
                  <a href="#显示错误" id="markdown-toc-显示错误">显示错误</a>
                </li>
                <li>
                  <a href="#在运行时接住错误" id="markdown-toc-在运行时接住错误"
                    >在运行时接住错误</a
                  >
                </li>
                <li>
                  <a href="#控制错误的位置" id="markdown-toc-控制错误的位置"
                    >控制错误的位置</a
                  >
                </li>
                <li>
                  <a href="#报告多个错误" id="markdown-toc-报告多个错误"
                    >报告多个错误</a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a
                href="#测试-megaparsec-语法分析器"
                id="markdown-toc-测试-megaparsec-语法分析器"
                >测试 Megaparsec 语法分析器</a
              >
            </li>
            <li>
              <a href="#使用自定义输入流" id="markdown-toc-使用自定义输入流"
                >使用自定义输入流</a
              >
            </li>
          </ul>

          <p>
            在上一章「例：编写自己的语法分析组合子」中编写的玩具性质的语法分析组合子并不适合实际使用，因此我们继续来看看
            Haskell 生态圈中能够解决相同问题的库，并请留意它们各自的利弊权衡：
          </p>

          <ul>
            <li>
              <a href="https://hackage.haskell.org/package/parsec">parsec</a>
              过去一直是 Haskell
              的「默认」语法分析库。该库比较关注错误信息的质量，但其测试覆盖率不高，并且目前处于仅维护的状态。
            </li>
            <li>
              <a href="https://hackage.haskell.org/package/attoparsec"
                >attoparsec</a
              >
              是个健壮而高性能的语法分析库。它是在列的库中唯一一个完整支持增量语法分析的，其缺点是错误信息质量不佳、不支持单子变换、只支持部分输入流类型。
            </li>
            <li>
              <a href="https://hackage.haskell.org/package/trifecta"
                >trifecta</a
              >
              错误信息的质量不错，但文档不足导致难以理解。对
              <code class="language-plaintext highlighter-rouge">String</code>
              和
              <code class="language-plaintext highlighter-rouge"
                >ByteString</code
              >
              的语法分析可以做到开箱即用，但
              <code class="language-plaintext highlighter-rouge">Text</code>
              则不行。
            </li>
            <li>
              <a href="https://hackage.haskell.org/package/megaparsec"
                >megaparsec</a
              >
              是
              <code class="language-plaintext highlighter-rouge">parsec</code>
              的一个分支，在过去数年里保持着积极的开发。当前版本尝试在速度、灵活性和错误信息质量之间找到一个最佳平衡。因为是
              <code class="language-plaintext highlighter-rouge">parsec</code>
              的非官方继任者，使用过
              <code class="language-plaintext highlighter-rouge">parsec</code>
              或者读过其教程的用户一定会对它感到十分亲切。
            </li>
          </ul>

          <p>
            把上述语法解析库全部讲一遍是不现实的，因此本文聚焦
            <code class="language-plaintext highlighter-rouge">megaparsec</code
            >。更准确地说，我们将会讲解该库的版本
            8.0，其于本书正式发行时应该已经取代旧版本成为主流版本了。
          </p>

          <h2 id="parsect-和-parsec-单子">
            <code class="language-plaintext highlighter-rouge">ParsecT</code> 和
            <code class="language-plaintext highlighter-rouge">Parsec</code>
            单子
          </h2>

          <p>
            <code class="language-plaintext highlighter-rouge">ParsecT</code> 是
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            中主要的语法分析单子变换和核心数据类型。<code
              class="language-plaintext highlighter-rouge"
              >ParsecT e s m a</code
            >
            各参数分别表示：
          </p>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">e</code>
              是用来表示错误信息的自定义组件的类型。如果我们不想做自定义（目前我们确实不想），那么用
              <code class="language-plaintext highlighter-rouge"
                >Data.Void</code
              >
              模块中的
              <code class="language-plaintext highlighter-rouge">Void</code>
              就行了。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">s</code>
              是输入流的类型。<code class="language-plaintext highlighter-rouge"
                >megaparsec</code
              >
              对于
              <code class="language-plaintext highlighter-rouge">String</code
              >、严格或惰性的
              <code class="language-plaintext highlighter-rouge">Text</code
              >、严格或惰性的
              <code class="language-plaintext highlighter-rouge"
                >ByteString</code
              >
              都是开箱即用的，当然自定义输入流也是可用的。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">m</code> 是
              <code class="language-plaintext highlighter-rouge">ParsecT</code>
              单子变换的内部单子。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">a</code>
              是单子中的值，作为语法分析的结果。
            </li>
          </ul>

          <p>
            因为大多数时候
            <code class="language-plaintext highlighter-rouge">m</code> 就是
            <code class="language-plaintext highlighter-rouge">Identity</code
            >，所以
            <code class="language-plaintext highlighter-rouge">Parsec</code>
            这个类型别名非常有用：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">Parsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">ParsecT</span> <span class="n">e</span> <span class="n">s</span> <span class="kt">Identity</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            简而言之，<code class="language-plaintext highlighter-rouge"
              >Parsec</code
            >
            就是没有单子变换的
            <code class="language-plaintext highlighter-rouge">ParsecT</code>。
          </p>

          <p>
            我们还可以把
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            的单子变换类比于 MTL 单子变换和类型类。确实，我们还有
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec</code
            >
            类型类的用途与
            <code class="language-plaintext highlighter-rouge">MonadState</code>
            和
            <code class="language-plaintext highlighter-rouge"
              >MonadReader</code
            >
            相近。我们会在<a href="#monadparsec-类型类">后面的章节</a>详细讨论
            <code class="language-plaintext highlighter-rouge">MonadParsec</code
            >。
          </p>

          <p>
            说到类型别名，开始使用
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            的最佳方式就是为自己的语法分析器定义一个类型别名。这有两个好处：
          </p>

          <ul>
            <li>
              添加顶级签名会更容易，例如
              <code class="language-plaintext highlighter-rouge"
                >Parser Int</code
              >，其中
              <code class="language-plaintext highlighter-rouge">Parser</code>
              是你的语法分析单子。没有签名，诸如
              <code class="language-plaintext highlighter-rouge">e</code>
              之类的参数会有歧义，这是多态 API 不利的一面。
            </li>
            <li>
              使用固定所有类型变量的具体类型可以帮助 GHC
              更好地进行优化，如果你的语法分析器保持多态则 GHC
              难以开展优化工作。尽管
              <code class="language-plaintext highlighter-rouge"
                >megaparsec</code
              >
              API
              是多态的，但预计最终用户都会使用具体类型的语法分析单子，这样便可进行内联工作，并将大多数函数定义转储到接口文件，这让
              GHC 能够生成非常高效的非多态代码。
            </li>
          </ul>

          <p>
            让我们定义一个类型别名（一般都叫
            <code class="language-plaintext highlighter-rouge">Parser</code>）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>
<span class="c1">--                   ^    ^</span>
<span class="cd">--                   |    |</span>
<span class="c1">-- Custom error component Type of input stream</span>
</code></pre>
            </div>
          </div>

          <p>
            在本文中出现的
            <code class="language-plaintext highlighter-rouge">Parser</code>
            假定为此类型，直到我们开始自定义语法分析错误为止。
          </p>

          <h2 id="字符和二进制流">字符和二进制流</h2>

          <p>
            我们之前说了
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            对于五种输入流类型是开箱即用的：<code
              class="language-plaintext highlighter-rouge"
              >String</code
            >、严格或惰性的
            <code class="language-plaintext highlighter-rouge">Text</code
            >、严格或惰性的
            <code class="language-plaintext highlighter-rouge">ByteString</code
            >。之所以可以这样，是因为在该库中这些类型都是
            <code class="language-plaintext highlighter-rouge">Stream</code>
            类型类的实例，其对所有可用作
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            语法分析器输入的数据类型做了功能上的抽象。
          </p>

          <p>
            简化版本的
            <code class="language-plaintext highlighter-rouge">Stream</code>
            可以表示如下：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">class</span> <span class="kt">Stream</span> <span class="n">s</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Token</span>  <span class="n">s</span> <span class="o">::</span> <span class="o">*</span>
  <span class="kr">type</span> <span class="kt">Tokens</span> <span class="n">s</span> <span class="o">::</span> <span class="o">*</span>
  <span class="n">take1_</span> <span class="o">::</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="c1">-- aka uncons</span>
  <span class="n">tokensToChunk</span> <span class="o">::</span> <span class="kt">Proxy</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Token</span> <span class="n">s</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Tokens</span> <span class="n">s</span>
</code></pre>
            </div>
          </div>

          <p>
            实际的
            <code class="language-plaintext highlighter-rouge">Stream</code>
            定义包含更多方法，但我们不用知道那些就能使用该库。
          </p>

          <p>注意这个类型类关联了两个类型函数：</p>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">Token s</code>
              是单个词法单词的类型。一般来说是
              <code class="language-plaintext highlighter-rouge">Char</code>
              或者
              <code class="language-plaintext highlighter-rouge">Word8</code
              >，但对于自定义流来说也可能是其他类型。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">Tokens s</code>
              是流的「一大块」的类型，此概念是为性能考虑而引入的。确实常常有相当于单词列表
              <code class="language-plaintext highlighter-rouge"
                >[Token s]</code
              >
              但又更加高效的表示方法，比如
              <code class="language-plaintext highlighter-rouge">Text</code>
              类型的输入流有
              <code class="language-plaintext highlighter-rouge"
                >Tokens s ~ Text</code
              >，即
              <code class="language-plaintext highlighter-rouge">Text</code>
              的一大块就是
              <code class="language-plaintext highlighter-rouge">Text</code
              >。虽然类型等式
              <code class="language-plaintext highlighter-rouge"
                >Tokens s ~ s</code
              >
              常常是成立的，但在自定义流中
              <code class="language-plaintext highlighter-rouge">Tokens s</code>
              和
              <code class="language-plaintext highlighter-rouge">s</code>
              可能不同，所以我们将这两个类型分开了。
            </li>
          </ul>

          <p>我们可以把所有默认的输入流列进一张表格：</p>

          <table>
            <thead>
              <tr>
                <th>
                  <code class="language-plaintext highlighter-rouge">s</code>
                </th>
                <th>
                  <code class="language-plaintext highlighter-rouge"
                    >Token s</code
                  >
                </th>
                <th>
                  <code class="language-plaintext highlighter-rouge"
                    >Tokens s</code
                  >
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >String</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge">Char</code>
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >String</code
                  >
                </td>
              </tr>
              <tr>
                <td>
                  strict
                  <code class="language-plaintext highlighter-rouge">Text</code>
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge">Char</code>
                </td>
                <td>
                  strict
                  <code class="language-plaintext highlighter-rouge">Text</code>
                </td>
              </tr>
              <tr>
                <td>
                  lazy
                  <code class="language-plaintext highlighter-rouge">Text</code>
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge">Char</code>
                </td>
                <td>
                  lazy
                  <code class="language-plaintext highlighter-rouge">Text</code>
                </td>
              </tr>
              <tr>
                <td>
                  strict
                  <code class="language-plaintext highlighter-rouge"
                    >ByteString</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >Word8</code
                  >
                </td>
                <td>
                  strict
                  <code class="language-plaintext highlighter-rouge"
                    >ByteString</code
                  >
                </td>
              </tr>
              <tr>
                <td>
                  lazy
                  <code class="language-plaintext highlighter-rouge"
                    >ByteString</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >Word8</code
                  >
                </td>
                <td>
                  lazy
                  <code class="language-plaintext highlighter-rouge"
                    >ByteString</code
                  >
                </td>
              </tr>
            </tbody>
          </table>

          <p>
            我们得习惯
            <code class="language-plaintext highlighter-rouge">Token</code> 和
            <code class="language-plaintext highlighter-rouge">Tokens</code>
            这两个类型函数，因为它们在
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            API 的类型声明中无处不在。
          </p>

          <p>
            你可能会注意到，如果我们把所有默认输入流按照单词类型分类，可以得到两类：
          </p>

          <ul>
            <li>
              字符流，满足
              <code class="language-plaintext highlighter-rouge"
                >Token s ~ Char</code
              >：<code class="language-plaintext highlighter-rouge">String</code
              >、严格或惰性的
              <code class="language-plaintext highlighter-rouge">Text</code>；
            </li>
            <li>
              二进制流，满足
              <code class="language-plaintext highlighter-rouge"
                >Token s ~ Word8</code
              >：严格或惰性的
              <code class="language-plaintext highlighter-rouge"
                >ByteString</code
              >。
            </li>
          </ul>

          <p>
            因此用
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            就不需要为每种输入流类型都编写一个同样的语法分析器（比如用
            <code class="language-plaintext highlighter-rouge">attoparsec</code>
            就需要），但我们仍要为不同的单词类型编写不同的代码：
          </p>

          <ul>
            <li>
              使用字符流的组合子，要导入
              <code class="language-plaintext highlighter-rouge"
                >Text.Megaparsec.Char</code
              >
              模块；
            </li>
            <li>
              使用二进制流的组合子，要导入
              <code class="language-plaintext highlighter-rouge"
                >Text.Megaparsec.Byte</code
              >
              模块。
            </li>
          </ul>

          <p>这些模块包含两组相似的语法分析工具，例如：</p>

          <table>
            <thead>
              <tr>
                <th> </th>
                <th>
                  <code class="language-plaintext highlighter-rouge"
                    >Text.Megaparsec.Char</code
                  >
                </th>
                <th>
                  <code class="language-plaintext highlighter-rouge"
                    >Text.Megaparsec.Byte</code
                  >
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >newline</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >(MonadParsec e s m, Token s ~ Char) =&gt; m (Token s)</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >(MonadParsec e s m, Token s ~ Word8) =&gt; m (Token
                    s)</code
                  >
                </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">eol</code>
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >(MonadParsec e s m, Token s ~ Char) =&gt; m (Tokens
                    s)</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >(MonadParsec e s m, Token s ~ Word8) =&gt; m (Tokens
                    s)</code
                  >
                </td>
              </tr>
            </tbody>
          </table>

          <p>
            为了更好地理解我们将使用的工具函数，我们先引入几个它们所依赖的原语。
          </p>

          <p>
            第一个原语是
            <code class="language-plaintext highlighter-rouge">token</code
            >，相应地它让我们能够对
            <code class="language-plaintext highlighter-rouge">Token s</code>
            类型的值做语法分析：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">token</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
    <span class="c1">-- ^ Matching function for the token to parse</span>
  <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span>
    <span class="c1">-- ^ Expected items (in case of an error)</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">token</code>
            的第一个参数是要分析的单词的匹配函数，如果该函数返回了
            <code class="language-plaintext highlighter-rouge">Just</code>
            那么其值就会成为语法分析的结果，<code
              class="language-plaintext highlighter-rouge"
              >Nothing</code
            >
            则表明语法分析器不接受该单词并且原语会失败。
          </p>

          <p>
            第二个参数是一个
            <code class="language-plaintext highlighter-rouge">Set</code>（来自
            <code class="language-plaintext highlighter-rouge">containers</code>
            包），它包含在失败的情况下所有可能显示给用户的
            <code class="language-plaintext highlighter-rouge">ErrorItem</code
            >。当我们讨论语法分析错误时会详细解说
            <code class="language-plaintext highlighter-rouge">ErrorItem</code
            >。
          </p>

          <p>
            为了更好地理解
            <code class="language-plaintext highlighter-rouge">token</code>
            是怎样工作的，让我们看看
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec</code
            >
            模块中适用于所有输入流类型的一些组合子的定义。<code
              class="language-plaintext highlighter-rouge"
              >satisfy</code
            >
            是其中一个相当常见的组合子，我们给它一个对匹配单词返回
            <code class="language-plaintext highlighter-rouge">True</code>
            的断言，它就会返回一个对应的语法分析器：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">satisfy</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="c1">-- ^ Predicate to apply</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)</span>
<span class="n">satisfy</span> <span class="n">f</span> <span class="o">=</span> <span class="n">token</span> <span class="n">testToken</span> <span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
  <span class="kr">where</span>
    <span class="n">testToken</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">x</span> <span class="kr">else</span> <span class="kt">Nothing</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">testToken</code>
            的工作就是把返回
            <code class="language-plaintext highlighter-rouge">Bool</code> 值的
            <code class="language-plaintext highlighter-rouge">f</code>
            函数转换为
            <code class="language-plaintext highlighter-rouge">token</code>
            期待的返回
            <code class="language-plaintext highlighter-rouge"
              >Maybe (Token s)</code
            >
            的函数。在
            <code class="language-plaintext highlighter-rouge">satisfy</code>
            中我们不知道想要匹配的确切单词序列，所以我们传了
            <code class="language-plaintext highlighter-rouge">Set.empty</code>
            作为第二个参数。
          </p>

          <p>
            <code class="language-plaintext highlighter-rouge">satisfy</code>
            看起来很好懂，让我们看看怎么使用它。我们需要一个能跑语法分析器的工具函数，<code
              class="language-plaintext highlighter-rouge"
              >megaparsec</code
            >
            提供了
            <code class="language-plaintext highlighter-rouge">parseTest</code>
            让我们在 GHCi 中测试。
          </p>

          <p>首先，让我们启动 GHCi 并导入一些模块：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; import Text.Megaparsec
λ&gt; import Text.Megaparsec.Char
λ&gt; import Data.Text (Text)
λ&gt; import Data.Void
</code></pre>
            </div>
          </div>

          <p>
            我们接着添加
            <code class="language-plaintext highlighter-rouge">Parser</code>
            类型别名，以明确语法分析器的类型：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; type Parser = Parsec Void Text
</code></pre>
            </div>
          </div>

          <p>
            我们还需要开启
            <code class="language-plaintext highlighter-rouge"
              >OverloadedStrings</code
            >
            语言扩展，这样我们就能把字符串字面量用作
            <code class="language-plaintext highlighter-rouge">Text</code>
            类型的值：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; :set -XOverloadedStrings
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (satisfy (== 'a') :: Parser Char) ""
1:1:
  |
1 | &lt;empty line&gt;
  | ^
unexpected end of input
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (satisfy (== 'a') :: Parser Char) "a"
'a'
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (satisfy (== 'a') :: Parser Char) "b"
1:1:
  |
1 | b
  | ^
unexpected 'b'
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (satisfy (&gt; 'c') :: Parser Char) "a"
1:1:
  |
1 | a
  | ^
unexpected 'a'
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (satisfy (&gt; 'c') :: Parser Char) "d"
'd'
</code></pre>
            </div>
          </div>

          <p>
            因为
            <code class="language-plaintext highlighter-rouge">satisfy</code>
            本身是多态的，所以
            <code class="language-plaintext highlighter-rouge"
              >:: Parser Char</code
            >
            类型标注是必要的，否则
            <code class="language-plaintext highlighter-rouge">parseTest</code>
            无法得知
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec e s m</code
            >
            中的 <code class="language-plaintext highlighter-rouge">e</code> 和
            <code class="language-plaintext highlighter-rouge">s</code>
            是什么（在这里
            <code class="language-plaintext highlighter-rouge">m</code> 假定为
            <code class="language-plaintext highlighter-rouge">Identity</code
            >）。如果我们使用的是一个事先存在的有类型签名的语法分析器，那么就不需要这些显式的类型标注了。
          </p>

          <p>
            看起来是正常工作的。<code
              class="language-plaintext highlighter-rouge"
              >satisfy</code
            >
            有个问题是它没有在失败时告诉我们它期待什么单词，因为我们无法分析
            <code class="language-plaintext highlighter-rouge">satisfy</code>
            调用者提供的函数。另外还有一些不那么通用的组合子，但它们生成更有用的错误信息。例如
            <code class="language-plaintext highlighter-rouge">single</code
            >（还有在
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Byte</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >Texy.Megaparsec.Char</code
            >
            中限定了类型的别名
            <code class="language-plaintext highlighter-rouge">char</code
            >）可以匹配一个特定的单词：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">single</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Token</span> <span class="n">s</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)</span>
<span class="n">single</span> <span class="n">t</span> <span class="o">=</span> <span class="n">token</span> <span class="n">testToken</span> <span class="n">expected</span>
  <span class="kr">where</span>
    <span class="n">testToken</span> <span class="n">x</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">t</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">x</span> <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="n">expected</span>    <span class="o">=</span> <span class="kt">E</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="p">(</span><span class="n">t</span><span class="o">:|</span><span class="kt">[]</span><span class="p">))</span>
</code></pre>
            </div>
          </div>

          <p>
            这里的
            <code class="language-plaintext highlighter-rouge">Tokens</code>
            数据类型构造器跟我们之前讨论的
            <code class="language-plaintext highlighter-rouge">Tokens</code>
            类型函数没有关系。实际上，<code
              class="language-plaintext highlighter-rouge"
              >Tokens</code
            >
            是
            <code class="language-plaintext highlighter-rouge">ErrorItem</code>
            的一个构造器，用来指定我们期望匹配的具体单词序列。
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (char 'a' :: Parser Char) "b"
1:1:
  |
1 | b
  | ^
unexpected 'b'
expecting 'a'
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (char 'a' :: Parser Char) "a"
'a'
</code></pre>
            </div>
          </div>

          <p>
            我们现在可以定义之前表格中的
            <code class="language-plaintext highlighter-rouge">newline</code>
            了：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">newline</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Token</span> <span class="n">s</span> <span class="o">~</span> <span class="kt">Char</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)</span>
<span class="n">newline</span> <span class="o">=</span> <span class="n">single</span> <span class="sc">'</span><span class="se">\n</span><span class="sc">'</span>
</code></pre>
            </div>
          </div>

          <p>
            第二个原语叫做
            <code class="language-plaintext highlighter-rouge">tokens</code
            >，它让我们能够语法分析
            <code class="language-plaintext highlighter-rouge">Tokens s</code
            >，即用来匹配输入的一大块：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">tokens</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Tokens</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>
    <span class="c1">-- ^ Predicate to check equality of chunks</span>
  <span class="o">-&gt;</span> <span class="kt">Tokens</span> <span class="n">s</span>
    <span class="c1">-- ^ Chunk of input to match against</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="n">s</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            也有两个语法分析器是基于
            <code class="language-plaintext highlighter-rouge">tokens</code>
            定义的：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="c1">-- from "Text.Megaparsec":</span>
<span class="n">chunk</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Tokens</span> <span class="n">s</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="n">s</span><span class="p">)</span>
<span class="n">chunk</span> <span class="o">=</span> <span class="n">tokens</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span>
</code></pre>
            </div>
          </div>
          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="c1">-- from "Text.Megaparsec.Char" and "Text.Megaparsec.Byte":</span>
<span class="n">string'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">CI</span><span class="o">.</span><span class="kt">FoldCase</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="n">s</span><span class="p">))</span>
  <span class="o">=&gt;</span> <span class="kt">Tokens</span> <span class="n">s</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="n">s</span><span class="p">)</span>
<span class="n">string'</span> <span class="o">=</span> <span class="n">tokens</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="kt">CI</span><span class="o">.</span><span class="n">mk</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            它们会匹配输入中固定的一大块，<code
              class="language-plaintext highlighter-rouge"
              >chunk</code
            >（在
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Byte</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >Texy.Megaparsec.Char</code
            >
            中有限定了类型的别名
            <code class="language-plaintext highlighter-rouge">string</code
            >）区分大小写，而
            <code class="language-plaintext highlighter-rouge">string'</code>
            不区分。不区分大小写的匹配要用到
            <code class="language-plaintext highlighter-rouge"
              >case-insensitive</code
            >
            包，并且加上了
            <code class="language-plaintext highlighter-rouge">FoldCase</code>
            约束。
          </p>

          <p>让我们也来试试这些新的组合子：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (string "foo" :: Parser Text) "foo"
"foo"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (string "foo" :: Parser Text) "bar"
1:1:
  |
1 | bar
  | ^
unexpected "bar"
expecting "foo"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (string' "foo" :: Parser Text) "FOO"
"FOO"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (string' "foo" :: Parser Text) "FoO"
"FoO"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (string' "foo" :: Parser Text) "FoZ"
1:1:
  |
1 | FoZ
  | ^
unexpected "FoZ"
expecting "foo"
</code></pre>
            </div>
          </div>

          <p>
            好的，我们可以匹配单个单词和一大块输入了。下一步我们将要学习如何组合这些积木来编写更有趣的语法分析器。
          </p>

          <h2 id="单子式和可应用函子式语法">单子式和可应用函子式语法</h2>

          <p>
            最简单的组合语法分析器的方式是连续执行它们。<code
              class="language-plaintext highlighter-rouge"
              >ParsecT</code
            >
            和
            <code class="language-plaintext highlighter-rouge">Parsec</code>
            是单子，而单子绑定正好可以顺序执行语法分析器：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">mySequence</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="n">mySequence</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">char</span> <span class="sc">'a'</span>
  <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">char</span> <span class="sc">'b'</span>
  <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">char</span> <span class="sc">'c'</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>我们来运行一下看看是不是按照预期工作：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest mySequence "abc"
('a','b','c')
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest mySequence "bcd"
1:1:
  |
1 | bcd
  | ^
unexpected 'b'
expecting 'a'
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest mySequence "adc"
1:2:
  |
1 | adc
  |  ^
unexpected 'd'
expecting 'b'
</code></pre>
            </div>
          </div>

          <p>
            因为所有单子亦是可应用函子，所以我们也可以使用可应用函子式的语法来顺序执行：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">mySequence</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="n">mySequence</span> <span class="o">=</span>
  <span class="p">(,,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span> <span class="sc">'a'</span>
       <span class="o">&lt;*&gt;</span> <span class="n">char</span> <span class="sc">'b'</span>
       <span class="o">&lt;*&gt;</span> <span class="n">char</span> <span class="sc">'c'</span>
</code></pre>
            </div>
          </div>

          <p>
            第二种方法跟第一种运行结果完全相同，使用哪种风格通常取决于个人品味。单子风格可以说是更冗长但有时更清晰，而可应用函子风格通常更简洁。话说回来，显然单子风格的表达能力更强，因为单子比可应用函子更强大。
          </p>

          <h2 id="用-eof-耗尽输入">
            用
            <code class="language-plaintext highlighter-rouge">eof</code>
            耗尽输入
          </h2>

          <p>
            可应用函子通常已经足够强大，足以做一些有趣的事情。如果配上拥有单位元且满足结合律的运算符，我们就得到了可应用函子上的单位半群，在
            Haskell 中表示为
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            类型类。<a
              href="https://hackage.haskell.org/package/parser-combinators"
              >parser-combinators</a
            >
            包提供了不少基于
            <code class="language-plaintext highlighter-rouge"
              >Applicative</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            概念的抽象组合子，<code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec</code
            >
            模块重新导出了这些来自
            <code class="language-plaintext highlighter-rouge"
              >Control.Applicative.Combinators</code
            >
            的组合子。
          </p>

          <p>
            一个最常见的组合子是
            <code class="language-plaintext highlighter-rouge">many</code
            >，它允许我们将给定的语法分析器运行零次或多次：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (many (char 'a') :: Parser [Char]) "aaa"
"aaa"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (many (char 'a') :: Parser [Char]) "aabbb"
"aa"
</code></pre>
            </div>
          </div>

          <p>
            第二个结果可能有点令人惊讶，语法分析器吃掉了匹配的
            <code class="language-plaintext highlighter-rouge">a</code
            >，但随后就停了下来。好吧，我们并没有交代在
            <code class="language-plaintext highlighter-rouge"
              >many (char 'a')</code
            >
            之后要做些什么。
          </p>

          <p>
            在大多数情况下，我们实际需要强制语法分析器吃掉整个输入，并报告语法分析错误，而不是害羞地默默中止。这就需要我们吃到输入结束。幸运的是，虽然输入结束只是一个概念，但有个
            <code class="language-plaintext highlighter-rouge"
              >eof :: MonadParsec e s m =&gt; m ()</code
            >
            不吃任何单词，仅会在输入结束时成功。让我们把它加进去再试一次：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (many (char 'a') &lt;* eof :: Parser [Char]) "aabbb"
1:3:
  |
1 | aabbb
  |   ^
unexpected 'b'
expecting 'a' or end of input
</code></pre>
            </div>
          </div>

          <p>
            我们在语法分析器中没有提到
            <code class="language-plaintext highlighter-rouge">b</code
            >，所以它们肯定是预期之外的。
          </p>

          <h2 id="处理多种选择">处理多种选择</h2>

          <p>
            从现在开始我们将开发一个实际有用的语法分析器，它能处理下述形式的
            URI：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
</code></pre>
            </div>
          </div>

          <p>
            我们记住方括号
            <code class="language-plaintext highlighter-rouge">[]</code>
            中的部分是可选的，不论它们出不出现 URI 都是合法的，<code
              class="language-plaintext highlighter-rouge"
              >[]</code
            >
            甚至可以进行嵌套。我们会完整支持该语法<sup
              id="fnref:modern-uri"
              role="doc-noteref"
              ><a href="#fn:modern-uri" class="footnote">1</a></sup
            >。
          </p>

          <p>
            让我们从
            <code class="language-plaintext highlighter-rouge">scheme</code>
            开始，我们仅仅接受已知的协议名，譬如
            <code class="language-plaintext highlighter-rouge">data</code
            >、<code class="language-plaintext highlighter-rouge">file</code
            >、<code class="language-plaintext highlighter-rouge">ftp</code
            >、<code class="language-plaintext highlighter-rouge">http</code
            >、<code class="language-plaintext highlighter-rouge">https</code
            >、<code class="language-plaintext highlighter-rouge">irc</code> 和
            <code class="language-plaintext highlighter-rouge">mailto</code>。
          </p>

          <p>
            我们用
            <code class="language-plaintext highlighter-rouge">string</code>
            匹配固定的字符序列，用
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            类型类中的
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            方法表示「选择」。代码如下：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="cp">{-# LANGUAGE RecordWildCards   #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span>
<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">State</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec.Char</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Text</span> <span class="k">as</span> <span class="n">T</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Text.Megaparsec.Char.Lexer</span> <span class="k">as</span> <span class="n">L</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>

<span class="n">pScheme</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="n">pScheme</span> <span class="o">=</span> <span class="n">string</span> <span class="s">"data"</span>
  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"file"</span>
  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"ftp"</span>
  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"http"</span>
  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"https"</span>
  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"irc"</span>
  <span class="o">&lt;|&gt;</span> <span class="n">string</span> <span class="s">"mailto"</span>
</code></pre>
            </div>
          </div>

          <p>试着运行一下：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pScheme ""
1:1:
  |
1 | &lt;empty line&gt;
  | ^
unexpected end of input
expecting "data", "file", "ftp", "http", "https", "irc", or "mailto"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pScheme "dat"
1:1:
  |
1 | dat
  | ^
unexpected "dat"
expecting "data", "file", "ftp", "http", "https", "irc", or "mailto"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pScheme "file"
"file"
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pScheme "irc"
"irc"
</code></pre>
            </div>
          </div>

          <p>
            看起来不错，但
            <code class="language-plaintext highlighter-rouge">pScheme</code>
            的定义有点啰嗦。我们可以用
            <code class="language-plaintext highlighter-rouge">choice</code>
            组合子重写
            <code class="language-plaintext highlighter-rouge">pScheme</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pScheme</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="n">pScheme</span> <span class="o">=</span> <span class="n">choice</span>
  <span class="p">[</span> <span class="n">string</span> <span class="s">"data"</span>
  <span class="p">,</span> <span class="n">string</span> <span class="s">"file"</span>
  <span class="p">,</span> <span class="n">string</span> <span class="s">"ftp"</span>
  <span class="p">,</span> <span class="n">string</span> <span class="s">"http"</span>
  <span class="p">,</span> <span class="n">string</span> <span class="s">"https"</span>
  <span class="p">,</span> <span class="n">string</span> <span class="s">"irc"</span>
  <span class="p">,</span> <span class="n">string</span> <span class="s">"mailto"</span> <span class="p">]</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">choice</code>
            只是
            <code class="language-plaintext highlighter-rouge">asum</code>
            的别名，后者会用
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            对列表元素进行折叠，所以
            <code class="language-plaintext highlighter-rouge">pScheme</code>
            的这两个定义其实是一样的，只是用
            <code class="language-plaintext highlighter-rouge">choice</code>
            更好看一些。
          </p>

          <p>
            协议名后面是个冒号
            <code class="language-plaintext highlighter-rouge">:</code
            >。回忆一下，如果我们要接着对其他东西做语法分析，我们要用单子绑定或者
            <code class="language-plaintext highlighter-rouge">do</code> 记法：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">Uri</span> <span class="o">=</span> <span class="kt">Uri</span>
  <span class="p">{</span> <span class="n">uriScheme</span> <span class="o">::</span> <span class="kt">Text</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="n">pUri</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Uri</span>
<span class="n">pUri</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">pScheme</span>
  <span class="kr">_</span> <span class="o">&lt;-</span> <span class="n">char</span> <span class="sc">':'</span>
  <span class="n">return</span> <span class="p">(</span><span class="kt">Uri</span> <span class="n">r</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            如果我们运行一下
            <code class="language-plaintext highlighter-rouge">pUri</code
            >，我们会看到它现在要求协议名后面跟着一个冒号：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "irc"
1:4:
  |
1 | irc
  |    ^
unexpected end of input
expecting ':'
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "irc:"
Uri {uriScheme = "irc"}
</code></pre>
            </div>
          </div>

          <p>
            但我们还没完成协议名的语法分析。一位优秀的 Haskell
            程序员编写的类型，能让错误数据无处遁形。并不是任何
            <code class="language-plaintext highlighter-rouge">Text</code>
            值都代表合法的协议名，因此让我们定义一个表示协议名的数据类型，并让
            <code class="language-plaintext highlighter-rouge">pScheme</code>
            返回它：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">Scheme</span>
  <span class="o">=</span> <span class="kt">SchemeData</span>
  <span class="o">|</span> <span class="kt">SchemeFile</span>
  <span class="o">|</span> <span class="kt">SchemeFtp</span>
  <span class="o">|</span> <span class="kt">SchemeHttp</span>
  <span class="o">|</span> <span class="kt">SchemeHttps</span>
  <span class="o">|</span> <span class="kt">SchemeIrc</span>
  <span class="o">|</span> <span class="kt">SchemeMailto</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="n">pScheme</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Scheme</span>
<span class="n">pScheme</span> <span class="o">=</span> <span class="n">choice</span>
  <span class="p">[</span> <span class="kt">SchemeData</span>   <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"data"</span>
  <span class="p">,</span> <span class="kt">SchemeFile</span>   <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"file"</span>
  <span class="p">,</span> <span class="kt">SchemeFtp</span>    <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"ftp"</span>
  <span class="p">,</span> <span class="kt">SchemeHttp</span>   <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"http"</span>
  <span class="p">,</span> <span class="kt">SchemeHttps</span>  <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"https"</span>
  <span class="p">,</span> <span class="kt">SchemeIrc</span>    <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"irc"</span>
  <span class="p">,</span> <span class="kt">SchemeMailto</span> <span class="o">&lt;$</span> <span class="n">string</span> <span class="s">"mailto"</span> <span class="p">]</span>

<span class="kr">data</span> <span class="kt">Uri</span> <span class="o">=</span> <span class="kt">Uri</span>
  <span class="p">{</span> <span class="n">uriScheme</span> <span class="o">::</span> <span class="kt">Scheme</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">(&lt;$)</code>
            运算符仅仅把左边的值放入函子上下文，而不管里面原来是什么。<code
              class="language-plaintext highlighter-rouge"
              >a &lt;$ f</code
            >
            与
            <code class="language-plaintext highlighter-rouge"
              >const a &lt;$&gt; f</code
            >
            等价，但对于一些函子来说更高效。
          </p>

          <p>让我们再来试一下：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "https:"
1:5:
  |
1 | https:
  |     ^
unexpected 's'
expecting ':'
</code></pre>
            </div>
          </div>

          <p>
            唔……<code class="language-plaintext highlighter-rouge">https</code>
            应该是个合法的协议名，你能看出哪里出错了吗？语法分析器逐个尝试这些选择，一旦
            <code class="language-plaintext highlighter-rouge">http</code>
            匹配就不会再往下试
            <code class="language-plaintext highlighter-rouge">https</code>
            了。解决方法就是把
            <code class="language-plaintext highlighter-rouge"
              >SchemeHttps &lt;$ string "https"</code
            >
            放到
            <code class="language-plaintext highlighter-rouge"
              >schemeHttp &lt;$ string "http"</code
            >
            上面去。一定要记住：顺序会影响选择！
          </p>

          <p>
            现在
            <code class="language-plaintext highlighter-rouge">pUri</code>
            正常工作了：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "http:"
Uri {uriScheme = SchemeHttp}
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "https:"
Uri {uriScheme = SchemeHttps}
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "mailto:"
Uri {uriScheme = SchemeMailto}
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest pUri "foo:"
1:1:
  |
1 | foo:
  | ^
unexpected "foo:"
expecting "data", "file", "ftp", "http", "https", "irc", or "mailto"
</code></pre>
            </div>
          </div>

          <h2 id="用-try-控制回溯">
            用
            <code class="language-plaintext highlighter-rouge">try</code>
            控制回溯
          </h2>

          <p>
            下一步是处理
            <code class="language-plaintext highlighter-rouge"
              >[//[user:password@]host[:port]]</code
            >，这里我们需要嵌套可选部分，因此让我们更新一下
            <code class="language-plaintext highlighter-rouge">Uri</code> 类型：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">Uri</span> <span class="o">=</span> <span class="kt">Uri</span>
  <span class="p">{</span> <span class="n">uriScheme</span>    <span class="o">::</span> <span class="kt">Scheme</span>
  <span class="p">,</span> <span class="n">uriAuthority</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Authority</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Authority</span> <span class="o">=</span> <span class="kt">Authority</span>
  <span class="p">{</span> <span class="n">authUser</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Text</span><span class="p">,</span> <span class="kt">Text</span><span class="p">)</span> <span class="c1">-- (user, password)</span>
  <span class="p">,</span> <span class="n">authHost</span> <span class="o">::</span> <span class="kt">Text</span>
  <span class="p">,</span> <span class="n">authPort</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            现在我们需要讨论一个重要概念，也就是回溯。回溯是指及时返回而不吃掉任何输入，这在处理分支是非常重要。下面是一个例子：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">alternatives</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="n">alternatives</span> <span class="o">=</span> <span class="n">foo</span> <span class="o">&lt;|&gt;</span> <span class="n">bar</span>
  <span class="kr">where</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span> <span class="sc">'a'</span> <span class="o">&lt;*&gt;</span> <span class="n">char</span> <span class="sc">'b'</span>
    <span class="n">bar</span> <span class="o">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span> <span class="sc">'a'</span> <span class="o">&lt;*&gt;</span> <span class="n">char</span> <span class="sc">'c'</span>
</code></pre>
            </div>
          </div>

          <p>看起来很合理，我们来试一下：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest alternatives "ab"
('a','b')
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest alternatives "ac"
1:2:
  |
1 | ac
  |  ^
unexpected 'c'
expecting 'b'
</code></pre>
            </div>
          </div>

          <p>
            发生了什么呢？最先尝试的
            <code class="language-plaintext highlighter-rouge">foo</code> 的
            <code class="language-plaintext highlighter-rouge">char 'a'</code>
            部分成功了，所以输入流里的
            <code class="language-plaintext highlighter-rouge">a</code>
            被吃掉了。接着
            <code class="language-plaintext highlighter-rouge">char 'b'</code>
            没能匹配
            <code class="language-plaintext highlighter-rouge">c</code
            >，所以我们得到了这样的错误信息。重要的一点是，<code
              class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            根本没有尝试
            <code class="language-plaintext highlighter-rouge">bar</code>，因为
            <code class="language-plaintext highlighter-rouge">foo</code>
            已经把一些输入吃掉了。
          </p>

          <p>
            一方面这是为性能考虑，另一方面把
            <code class="language-plaintext highlighter-rouge">foo</code>
            剩下来的东西喂给
            <code class="language-plaintext highlighter-rouge">bar</code>
            也没什么意义。我们期望在
            <code class="language-plaintext highlighter-rouge">bar</code>
            运行的时候，输入流正处于
            <code class="language-plaintext highlighter-rouge">foo</code>
            开始的位置。<code class="language-plaintext highlighter-rouge"
              >megaparsec</code
            >
            并不会自动回溯（与
            <code class="language-plaintext highlighter-rouge">attoparsec</code>
            或是上一章中的玩具组合子不同），所以我们需要用
            <code class="language-plaintext highlighter-rouge">try</code>
            原语来显式表达我们想要回溯。如果
            <code class="language-plaintext highlighter-rouge">p</code>
            失败了，那么
            <code class="language-plaintext highlighter-rouge">try p</code>
            就会进行回溯，就像没有输入被吃掉一样（实际上它回溯了整个语法分析状态）。这就允许
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            尝试右边的选择了：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">alternatives</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="n">alternatives</span> <span class="o">=</span> <span class="n">try</span> <span class="n">foo</span> <span class="o">&lt;|&gt;</span> <span class="n">bar</span>
  <span class="kr">where</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span> <span class="sc">'a'</span> <span class="o">&lt;*&gt;</span> <span class="n">char</span> <span class="sc">'b'</span>
    <span class="n">bar</span> <span class="o">=</span> <span class="p">(,)</span> <span class="o">&lt;$&gt;</span> <span class="n">char</span> <span class="sc">'a'</span> <span class="o">&lt;*&gt;</span> <span class="n">char</span> <span class="sc">'c'</span>
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest alternatives "ac"
('a','c')
</code></pre>
            </div>
          </div>

          <p>
            所有会吃输入的原语（当然也有诸如
            <code class="language-plaintext highlighter-rouge">try</code>
            这样改变现有语法分析器行为的原语）的输入消耗是「原子性」的。也就是说，它们失败时会自动回溯，所以它们不会吃掉部分输入而中途失败。这就是为什么
            <code class="language-plaintext highlighter-rouge">pScheme</code>
            的所有选择能正常工作：<code
              class="language-plaintext highlighter-rouge"
              >string</code
            >
            是基于
            <code class="language-plaintext highlighter-rouge">tokens</code>
            定义的，而
            <code class="language-plaintext highlighter-rouge">tokens</code>
            是原语。我们要么匹配整个字符串，要么直接失败而不吃掉任何输入流。
          </p>

          <p>
            回到 URI 的语法分析上，<code
              class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            能够用来构建一个方便的
            <code class="language-plaintext highlighter-rouge">optional</code>
            组合子：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">optional</span> <span class="o">::</span> <span class="kt">Alternative</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span>
<span class="n">optional</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">Just</span> <span class="o">&lt;$&gt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="n">pure</span> <span class="kt">Nothing</span>
</code></pre>
            </div>
          </div>

          <p>
            如果
            <code class="language-plaintext highlighter-rouge">optional p</code>
            中的
            <code class="language-plaintext highlighter-rouge">p</code>
            匹配成功了，那么我们能得到包装在
            <code class="language-plaintext highlighter-rouge">Just</code>
            中的结果，否则返回
            <code class="language-plaintext highlighter-rouge">Nothing</code
            >。这就是我们想要的！但我们没必要自己定义
            <code class="language-plaintext highlighter-rouge">optional</code
            >，因为
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec</code
            >
            帮我们重新导出了这个组合子。我们现在可以把它用在
            <code class="language-plaintext highlighter-rouge">pUri</code>
            上了：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pUri</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Uri</span>
<span class="n">pUri</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">uriScheme</span> <span class="o">&lt;-</span> <span class="n">pScheme</span>
  <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
  <span class="n">uriAuthority</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="o">.</span> <span class="n">try</span> <span class="o">$</span> <span class="kr">do</span>            <span class="c1">-- (1)</span>
    <span class="n">void</span> <span class="p">(</span><span class="n">string</span> <span class="s">"//"</span><span class="p">)</span>
    <span class="n">authUser</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="o">.</span> <span class="n">try</span> <span class="o">$</span> <span class="kr">do</span>              <span class="c1">-- (2)</span>
      <span class="n">user</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>       <span class="c1">-- (3)</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
      <span class="n">password</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'@'</span><span class="p">)</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>
    <span class="n">authHost</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="p">(</span><span class="n">alphaNumChar</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'.'</span><span class="p">)</span>
    <span class="n">authPort</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span> <span class="o">*&gt;</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span><span class="p">)</span> <span class="c1">-- (4)</span>
    <span class="n">return</span> <span class="kt">Authority</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>                        <span class="c1">-- (5)</span>
  <span class="n">return</span> <span class="kt">Uri</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>                                <span class="c1">-- (6)</span>
</code></pre>
            </div>
          </div>

          <p>
            我擅自让所有字母和数字都可用作用户名和密码，主机名也做了相似的简化。
          </p>

          <p>有几点需要留意：</p>

          <ul>
            <li>
              在 (1) 和 (2) 中我们需要把
              <code class="language-plaintext highlighter-rouge">optional</code>
              的参数用
              <code class="language-plaintext highlighter-rouge">try</code>
              包起来，因为其参数是组合起来的语法分析器，而不是原语。
            </li>
            <li>
              (3)
              <code class="language-plaintext highlighter-rouge">some</code> 和
              <code class="language-plaintext highlighter-rouge">many</code>
              很像，但要求至少匹配一次：<code
                class="language-plaintext highlighter-rouge"
                >some p = (:) &lt;$&gt; p &lt;*&gt; many p</code
              >。
            </li>
            <li>
              (4) 如非必要请勿使用
              <code class="language-plaintext highlighter-rouge">try</code
              >！这里如果
              <code class="language-plaintext highlighter-rouge">char ':'</code>
              成功了（它本身是基于
              <code class="language-plaintext highlighter-rouge">token</code>
              定义的，不需要
              <code class="language-plaintext highlighter-rouge">try</code
              >），我们知道紧接着一定是端口号，所以我们只需要
              <code class="language-plaintext highlighter-rouge"
                >L.decimal</code
              >
              来匹配十进制数。在匹配完
              <code class="language-plaintext highlighter-rouge">:</code>
              之后，我们并不需要回溯。
            </li>
            <li>
              在 (5) 和 (6) 中我们用
              <code class="language-plaintext highlighter-rouge"
                >RecordWildCards</code
              >
              语言扩展组装了
              <code class="language-plaintext highlighter-rouge"
                >Authority</code
              >
              和
              <code class="language-plaintext highlighter-rouge">Uri</code>
              的值。
            </li>
          </ul>

          <p>
            在 GHCi 中试试
            <code class="language-plaintext highlighter-rouge">pUri</code
            >，你会发现它能正常工作：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark:secret@example.com"
Uri
  { uriScheme = SchemeHttps
  , uriAuthority = Just (Authority
    { authUser = Just ("mark","secret")
    , authHost = "example.com"
    , authPort = Nothing } ) }
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark:secret@example.com:123"
Uri
  { uriScheme = SchemeHttps
  , uriAuthority = Just (Authority
    { authUser = Just ("mark","secret")
    , authHost = "example.com"
    , authPort = Just 123 } ) }
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://example.com:123"
Uri
  { uriScheme = SchemeHttps
  , uriAuthority = Just (Authority
    { authUser = Nothing
    , authHost = "example.com"
    , authPort = Just 123 } ) }
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark@example.com:123"
1:13:
  |
1 | https://mark@example.com:123
  |             ^
unexpected '@'
expecting '.', ':', alphanumeric character, or end of input
</code></pre>
            </div>
          </div>

          <h2 id="调试语法分析器">调试语法分析器</h2>

          <p>不过，你可能会发现这样一个问题：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark:@example.com"
1:7:
  |
1 | https://mark:@example.com
  |       ^
unexpected '/'
expecting end of input
</code></pre>
            </div>
          </div>

          <p>
            这个语法分析错误的提示信息有待改进！怎么改进呢？弄清问题所在的最简单方法是用内置的
            <code class="language-plaintext highlighter-rouge">dbg</code> 工具：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">dbg</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">s</span><span class="p">,</span> <span class="kt">ShowToken</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">),</span> <span class="kt">ShowErrorComponent</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Show</span> <span class="n">a</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="kt">String</span>            <span class="c1">-- ^ Debugging label</span>
  <span class="o">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>   <span class="c1">-- ^ Parser to debug</span>
  <span class="o">-&gt;</span> <span class="kt">ParsecT</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>   <span class="c1">-- ^ Parser that prints debugging messages</span>
</code></pre>
            </div>
          </div>

          <p>
            让我们把它加进
            <code class="language-plaintext highlighter-rouge">pUri</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pUri</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Uri</span>
<span class="n">pUri</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">uriScheme</span> <span class="o">&lt;-</span> <span class="n">dbg</span> <span class="s">"scheme"</span> <span class="n">pScheme</span>
  <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
  <span class="n">uriAuthority</span> <span class="o">&lt;-</span> <span class="n">dbg</span> <span class="s">"auth"</span> <span class="o">.</span> <span class="n">optional</span> <span class="o">.</span> <span class="n">try</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">void</span> <span class="p">(</span><span class="n">string</span> <span class="s">"//"</span><span class="p">)</span>
    <span class="n">authUser</span> <span class="o">&lt;-</span> <span class="n">dbg</span> <span class="s">"user"</span> <span class="o">.</span> <span class="n">optional</span> <span class="o">.</span> <span class="n">try</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="n">user</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
      <span class="n">password</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'@'</span><span class="p">)</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>
    <span class="n">authHost</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">dbg</span> <span class="s">"host"</span> <span class="p">(</span><span class="n">some</span> <span class="p">(</span><span class="n">alphaNumChar</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'.'</span><span class="p">))</span>
    <span class="n">authPort</span> <span class="o">&lt;-</span> <span class="n">dbg</span> <span class="s">"port"</span> <span class="o">$</span> <span class="n">optional</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span> <span class="o">*&gt;</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span><span class="p">)</span>
    <span class="n">return</span> <span class="kt">Authority</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
  <span class="n">return</span> <span class="kt">Uri</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
</code></pre>
            </div>
          </div>

          <p>
            然后再用刚才的输入运行
            <code class="language-plaintext highlighter-rouge">pUri</code>
            看看：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark:@example.com"
scheme&gt; IN: "https://mark:@example.com"
scheme&gt; MATCH (COK): "https"
scheme&gt; VALUE: SchemeHttps

user&gt; IN: "mark:@example.com"
user&gt; MATCH (EOK): &lt;EMPTY&gt;
user&gt; VALUE: Nothing

host&gt; IN: "mark:@example.com"
host&gt; MATCH (COK): "mark"
host&gt; VALUE: "mark"

port&gt; IN: ":@example.com"
port&gt; MATCH (CERR): ':'
port&gt; ERROR:
port&gt; 1:14:
port&gt; unexpected '@'
port&gt; expecting integer

auth&gt; IN: "//mark:@example.com"
auth&gt; MATCH (EOK): &lt;EMPTY&gt;
auth&gt; VALUE: Nothing

1:7:
  |
1 | https://mark:@example.com
  |       ^
unexpected '/'
expecting end of input
</code></pre>
            </div>
          </div>

          <p>我们可以看到内部到底发生什么了：</p>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">scheme</code>
              匹配成功了。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">user</code>
              失败了：虽然有个用户名
              <code class="language-plaintext highlighter-rouge">mark</code>，但
              <code class="language-plaintext highlighter-rouge">:</code>
              后面没有密码（我们这里要求密码非空）。虽然我们失败了，但
              <code class="language-plaintext highlighter-rouge">try</code>
              带我们回溯了。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">host</code> 从
              <code class="language-plaintext highlighter-rouge">user</code>
              开始的位置运作，并尝试把输入解释成主机名。我们可以看到它成功了，并返回了主机名
              <code class="language-plaintext highlighter-rouge">mark</code>。
            </li>
            <li>
              主机名后面可以有端口号，所以
              <code class="language-plaintext highlighter-rouge">port</code>
              开始运作。它看见了
              <code class="language-plaintext highlighter-rouge">:</code
              >，但发现后面没有数字，因此也失败了。
            </li>
            <li>
              因此整个
              <code class="language-plaintext highlighter-rouge">auth</code>
              语法分析失败了（<code class="language-plaintext highlighter-rouge"
                >port</code
              >
              在
              <code class="language-plaintext highlighter-rouge">auth</code>
              里面失败了）。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">auth</code>
              语法分析器返回了
              <code class="language-plaintext highlighter-rouge">Nothing</code
              >，因为它什么都分析不出来。现在
              <code class="language-plaintext highlighter-rouge">eof</code>
              要求吃到输入结束，但现实并非如此，因此我们得到了最终的错误信息。
            </li>
          </ul>

          <p>
            我们怎么办呢？这是一个用
            <code class="language-plaintext highlighter-rouge">try</code>
            包住一大堆代码导致错误信息不可读的例子。让我们再看一下我们要处理的语法：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
</code></pre>
            </div>
          </div>

          <p>
            我们在找什么？在找可以让我们确定特定分支的东西，就像我们看到
            <code class="language-plaintext highlighter-rouge">:</code>
            就肯定后面跟着端口号一样。如果仔细找的话，你会发现双斜杠是
            <code class="language-plaintext highlighter-rouge">//</code> 是进入
            <code class="language-plaintext highlighter-rouge">Authority</code>
            部分的标志。因为我们是用原子性的语法分析器（<code
              class="language-plaintext highlighter-rouge"
              >string</code
            >）来匹配
            <code class="language-plaintext highlighter-rouge">//</code>
            的，它会自动回溯，而一旦匹配到
            <code class="language-plaintext highlighter-rouge">//</code>
            我们就能确定我们需要匹配到
            <code class="language-plaintext highlighter-rouge">Authority</code>
            部分。让我们把
            <code class="language-plaintext highlighter-rouge">pUri</code>
            的第一个
            <code class="language-plaintext highlighter-rouge">try</code>
            删掉吧：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pUri</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Uri</span>
<span class="n">pUri</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">uriScheme</span> <span class="o">&lt;-</span> <span class="n">pScheme</span>
  <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
  <span class="n">uriAuthority</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="o">$</span> <span class="kr">do</span> <span class="c1">-- removed 'try' on this line</span>
    <span class="n">void</span> <span class="p">(</span><span class="n">string</span> <span class="s">"//"</span><span class="p">)</span>
    <span class="n">authUser</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="o">.</span> <span class="n">try</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="n">user</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
      <span class="n">password</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'@'</span><span class="p">)</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>
    <span class="n">authHost</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="p">(</span><span class="n">alphaNumChar</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'.'</span><span class="p">)</span>
    <span class="n">authPort</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span> <span class="o">*&gt;</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span><span class="p">)</span>
    <span class="n">return</span> <span class="kt">Authority</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
  <span class="n">return</span> <span class="kt">Uri</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
</code></pre>
            </div>
          </div>

          <p>现在我们得到了更可读的错误信息：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark:@example.com"
1:14:
  |
1 | https://mark:@example.com
  |              ^
unexpected '@'
expecting integer
</code></pre>
            </div>
          </div>

          <p>
            虽然有点误导人，但这是个比较微妙的例子。里面有太多
            <code class="language-plaintext highlighter-rouge">optional</code>
            了。
          </p>

          <h2 id="标签和隐藏">标签和隐藏</h2>

          <p>
            有时完整列出我们期待的东西会有点长，记得我们用未知的协议名进行测试的时候吗？
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "foo://example.com"
1:1:
  |
1 | foo://example.com
  | ^
unexpected "foo://"
expecting "data", "file", "ftp", "http", "https", "irc", or "mailto"
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            提供了对提示信息进行自定义的方法，即使用「标签」。我们可以这样使用
            <code class="language-plaintext highlighter-rouge">label</code>
            原语（它有个别名是
            <code class="language-plaintext highlighter-rouge"
              >(&lt;?&gt;)</code
            >
            运算符）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pUri</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Uri</span>
<span class="n">pUri</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">uriScheme</span> <span class="o">&lt;-</span> <span class="n">pScheme</span> <span class="o">&lt;?&gt;</span> <span class="s">"valid scheme"</span>
  <span class="c1">-- the rest stays the same</span>
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "foo://example.com"
1:1:
  |
1 | foo://example.com
  | ^
unexpected "foo://"
expecting valid scheme
</code></pre>
            </div>
          </div>

          <p>我们可以继续加入更多标签，以使错误信息更加可读：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pUri</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Uri</span>
<span class="n">pUri</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">uriScheme</span> <span class="o">&lt;-</span> <span class="n">pScheme</span> <span class="o">&lt;?&gt;</span> <span class="s">"valid scheme"</span>
  <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
  <span class="n">uriAuthority</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">void</span> <span class="p">(</span><span class="n">string</span> <span class="s">"//"</span><span class="p">)</span>
    <span class="n">authUser</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="o">.</span> <span class="n">try</span> <span class="o">$</span> <span class="kr">do</span>
      <span class="n">user</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span> <span class="o">&lt;?&gt;</span> <span class="s">"username"</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span><span class="p">)</span>
      <span class="n">password</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span> <span class="o">&lt;?&gt;</span> <span class="s">"password"</span>
      <span class="n">void</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'@'</span><span class="p">)</span>
      <span class="n">return</span> <span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">password</span><span class="p">)</span>
    <span class="n">authHost</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="p">(</span><span class="n">alphaNumChar</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'.'</span><span class="p">)</span> <span class="o">&lt;?&gt;</span> <span class="s">"hostname"</span>
    <span class="n">authPort</span> <span class="o">&lt;-</span> <span class="n">optional</span> <span class="p">(</span><span class="n">char</span> <span class="sc">':'</span> <span class="o">*&gt;</span> <span class="n">label</span> <span class="s">"port number"</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span><span class="p">)</span>
    <span class="n">return</span> <span class="kt">Authority</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
  <span class="n">return</span> <span class="kt">Uri</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span>
</code></pre>
            </div>
          </div>

          <p>举个例子：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pUri &lt;* eof) "https://mark:@example.com"
1:14:
  |
1 | https://mark:@example.com
  |              ^
unexpected '@'
expecting port number
</code></pre>
            </div>
          </div>

          <p>
            另一个原语叫做
            <code class="language-plaintext highlighter-rouge">hidden</code
            >。如果说
            <code class="language-plaintext highlighter-rouge">label</code>
            是在为提示信息进行重命名，那么
            <code class="language-plaintext highlighter-rouge">hidden</code>
            就是把它们直接移除了。做个比较：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (many (char 'a') &gt;&gt; many (char 'b') &gt;&gt; eof :: Parser ()) "d"
1:1:
  |
1 | d
  | ^
unexpected 'd'
expecting 'a', 'b', or end of input
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (many (char 'a') &gt;&gt; hidden (many (char 'b')) &gt;&gt; eof :: Parser ()) "d"
1:1:
  |
1 | d
  | ^
unexpected 'd'
expecting 'a' or end of input
</code></pre>
            </div>
          </div>

          <p>
            如果我们想让错误信息不那么啰嗦，<code
              class="language-plaintext highlighter-rouge"
              >hidden</code
            >
            会很有用。比如说，在对编程语言做语法分析时，最好丢弃「expecting
            white space」的提示信息，因为几乎所有单词后面都可以有空格。
          </p>

          <p>
            【练习】我们把
            <code class="language-plaintext highlighter-rouge">pUri</code>
            的剩余部分留给读者完成，所有要用到的工具都已经讲解过了。
          </p>

          <h2 id="运行语法分析器">运行语法分析器</h2>

          <p>
            我们已经探索了如何构建语法分析器，但我们还没审视能让我们运行它们的函数，除了
            <code class="language-plaintext highlighter-rouge">parseTest</code
            >。
          </p>

          <p>
            传统上来说，从你的程序运行语法分析器的「默认」函数一直是
            <code class="language-plaintext highlighter-rouge">parse</code
            >，但<code class="language-plaintext highlighter-rouge">parse</code>
            其实是
            <code class="language-plaintext highlighter-rouge">runParser</code>
            的别名：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">runParser</span>
  <span class="o">::</span> <span class="kt">Parsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">a</span> <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>       <span class="c1">-- ^ Name of source file</span>
  <span class="o">-&gt;</span> <span class="n">s</span>            <span class="c1">-- ^ Input for parser</span>
  <span class="o">-&gt;</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">ParseErrorBundle</span> <span class="n">s</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            第二个参数只是用来在错误信息中显示的文件名，<code
              class="language-plaintext highlighter-rouge"
              >megaparsec</code
            >
            并不会尝试去读这个文件，因为真正的输入是这个函数的第三个参数。
          </p>

          <p>
            <code class="language-plaintext highlighter-rouge">runParser</code>
            允许我们运行
            <code class="language-plaintext highlighter-rouge">Parsec</code>
            单子，我们已经知道，它就是没有单子变换的
            <code class="language-plaintext highlighter-rouge">ParsecT</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">Parsec</span> <span class="n">e</span> <span class="n">s</span> <span class="o">=</span> <span class="kt">ParsecT</span> <span class="n">e</span> <span class="n">s</span> <span class="kt">Identity</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">runParser</code>
            有三个姊妹：<code class="language-plaintext highlighter-rouge"
              >runParser'</code
            >、<code class="language-plaintext highlighter-rouge"
              >runParserT</code
            >
            和
            <code class="language-plaintext highlighter-rouge">runParserT'</code
            >。有后缀
            <code class="language-plaintext highlighter-rouge">T</code>
            的版本可以进行
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            单子变换，而有一撇的版本接受并返回语法分析器状态。让我们把它们列进一张表：
          </p>

          <table>
            <thead>
              <tr>
                <th>参数</th>
                <th>
                  运行
                  <code class="language-plaintext highlighter-rouge"
                    >Parsec</code
                  >
                </th>
                <th>
                  运行
                  <code class="language-plaintext highlighter-rouge"
                    >ParsecT</code
                  >
                </th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>输入和文件名</td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >runParser</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >runParserT</code
                  >
                </td>
              </tr>
              <tr>
                <td>自定义初始状态</td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >runParser'</code
                  >
                </td>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >runParserT'</code
                  >
                </td>
              </tr>
            </tbody>
          </table>

          <p>
            比如当你需要设置制表符宽度（默认是
            8）的时候，自定义初始状态就很有用。举了例子，下面是
            <code class="language-plaintext highlighter-rouge">runParser'</code>
            的类型签名：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">runParser'</span>
  <span class="o">::</span> <span class="kt">Parsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">a</span> <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">State</span> <span class="n">s</span>      <span class="c1">-- ^ Initial state</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">ParseErrorBundle</span> <span class="n">s</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            手动修改
            <code class="language-plaintext highlighter-rouge">State</code>
            是该库的高级用法，我们不会在这里介绍。
          </p>

          <h2 id="monadparsec-类型类">
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec</code
            >
            类型类
          </h2>

          <p>
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            中的所有工具都可用于
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec</code
            >
            类型类的任何实例。该类型类抽象了「组合子原语」，即所有
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            语法分析器的基本单元，这些组合子无法用其它组合子来表示。
          </p>

          <p>
            将组合子原语定义为类型类，让
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            具体的主要单子变换得以包装在我们熟悉的 MTL
            系单子变换中，从而实现在单子栈各层之间的不同交互。为了更好地理解其动机，请回忆一下单子栈各层的顺序很重要。如果我们这样组合
            <code class="language-plaintext highlighter-rouge">ReaderT</code> 和
            <code class="language-plaintext highlighter-rouge">State</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">MyStack</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">ReaderT</span> <span class="kt">MyContext</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">MyState</span><span class="p">)</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            在外层，<code class="language-plaintext highlighter-rouge"
              >ReaderT</code
            >
            无法检查里面
            <code class="language-plaintext highlighter-rouge">m</code>
            层的内部结构。<code class="language-plaintext highlighter-rouge"
              >ReaderT</code
            >
            的
            <code class="language-plaintext highlighter-rouge">Monad</code>
            实例描述了绑定策略：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">newtype</span> <span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">ReaderT</span> <span class="p">{</span> <span class="n">runReaderT</span> <span class="o">::</span> <span class="n">r</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span> <span class="o">=</span> <span class="kt">ReaderT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">runReaderT</span> <span class="n">m</span> <span class="n">r</span>
    <span class="n">runReaderT</span> <span class="p">(</span><span class="n">k</span> <span class="n">a</span><span class="p">)</span> <span class="n">r</span>
</code></pre>
            </div>
          </div>

          <p>
            实际上，我们对
            <code class="language-plaintext highlighter-rouge">m</code>
            的唯一了解是它是
            <code class="language-plaintext highlighter-rouge">Monad</code>
            的一个实例，因此
            <code class="language-plaintext highlighter-rouge">m</code>
            的状态只能通过单子绑定传给
            <code class="language-plaintext highlighter-rouge">k</code
            >。总之，这就是
            <code class="language-plaintext highlighter-rouge">ReaderT</code> 的
            <code class="language-plaintext highlighter-rouge"
              >(&gt;&gt;=)</code
            >
            起到的典型作用。
          </p>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            的
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            方法有着不同的作用：它「分裂」了状态，并且这两个语法分析分支不再有交集，因此在某种意义上我们可以回溯状态。也就是说，如果第一个分支被丢弃，那么它对状态的修改也会被丢弃，并不会影响到第二个分支（相当于我们在第一个分支失败时回溯了状态）。
          </p>

          <p>
            举个例子，我们可以看看
            <code class="language-plaintext highlighter-rouge">ReaderT</code> 的
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            实例：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">instance</span> <span class="kt">Alternative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Alternative</span> <span class="p">(</span><span class="kt">ReaderT</span> <span class="n">r</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">empty</span> <span class="o">=</span> <span class="n">liftReaderT</span> <span class="n">empty</span>
  <span class="kt">ReaderT</span> <span class="n">m</span> <span class="o">&lt;|&gt;</span> <span class="kt">ReaderT</span> <span class="n">n</span> <span class="o">=</span> <span class="kt">ReaderT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">r</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">r</span> <span class="o">&lt;|&gt;</span> <span class="n">n</span> <span class="n">r</span>
</code></pre>
            </div>
          </div>

          <p>
            这很棒，因为
            <code class="language-plaintext highlighter-rouge">ReaderT</code>
            是个「无状态」的单子变换，并且很容易将实际工作委托给内部单子（在这里
            <code class="language-plaintext highlighter-rouge">m</code> 的
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            实例很有用），而无需组合
            <code class="language-plaintext highlighter-rouge">ReaderT</code>
            自身的单子状态（它并没有）。
          </p>

          <p>
            现在我们来看看
            <code class="language-plaintext highlighter-rouge">State</code
            >，因为
            <code class="language-plaintext highlighter-rouge">State s a</code>
            只是
            <code class="language-plaintext highlighter-rouge"
              >StateT s Identity a</code
            >
            的别名，我们应该看看
            <code class="language-plaintext highlighter-rouge">StateT s m</code>
            的
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            实例：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">instance</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Alternative</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">Alternative</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">empty</span> <span class="o">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="n">empty</span>
  <span class="kt">StateT</span> <span class="n">m</span> <span class="o">&lt;|&gt;</span> <span class="kt">StateT</span> <span class="n">n</span> <span class="o">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">s</span> <span class="o">&lt;|&gt;</span> <span class="n">n</span> <span class="n">s</span>
</code></pre>
            </div>
          </div>

          <p>
            这里我们看到了状态
            <code class="language-plaintext highlighter-rouge">s</code>
            的分裂，正如我们看到了上下文
            <code class="language-plaintext highlighter-rouge">r</code>
            的共享。它们的区别是，表达式
            <code class="language-plaintext highlighter-rouge">m s</code> 和
            <code class="language-plaintext highlighter-rouge">n s</code>
            会产生有状态的结果：除了单子中的值，它们还会在元组中返回新的状态。这里我们要么走
            <code class="language-plaintext highlighter-rouge">m s</code> 要么走
            <code class="language-plaintext highlighter-rouge">n s</code
            >，自然实现了回溯。
          </p>

          <p>
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            又如何呢？让我们考虑像下面这样把
            <code class="language-plaintext highlighter-rouge">State</code> 放进
            <code class="language-plaintext highlighter-rouge">ParsecT</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">MyStack</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">MyState</span><span class="p">)</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">ParsecT</code> 比
            <code class="language-plaintext highlighter-rouge">ReaderT</code>
            更复杂，所以它的
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            实现得做更多工作：
          </p>

          <ul>
            <li>管理语法分析器本身的状态；</li>
            <li>合并语法分析错误，如果有的话。</li>
          </ul>

          <p>
            因此
            <code class="language-plaintext highlighter-rouge">ParsecT</code> 的
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            实例中的
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            实现无法将其工作委托给内部单子
            <code class="language-plaintext highlighter-rouge"
              >State MyState</code
            >
            的
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            实例，所以
            <code class="language-plaintext highlighter-rouge">MyState</code>
            不会分裂，我们也不能回溯。
          </p>

          <p>让我们用一个例子来证明这一点：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State.Strict</span>
<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">State</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">ParsecT</span> <span class="kt">Void</span> <span class="kt">Text</span> <span class="p">(</span><span class="kt">State</span> <span class="kt">String</span><span class="p">)</span>

<span class="n">parser0</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">parser0</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>
  <span class="kr">where</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">"foo"</span> <span class="o">&lt;$</span> <span class="n">put</span> <span class="s">"branch A"</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">get</span>   <span class="o">&lt;*</span> <span class="n">put</span> <span class="s">"branch B"</span>

<span class="n">parser1</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">parser1</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>
  <span class="kr">where</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">"foo"</span> <span class="o">&lt;$</span> <span class="n">put</span> <span class="s">"branch A"</span> <span class="o">&lt;*</span> <span class="n">empty</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">get</span>   <span class="o">&lt;*</span> <span class="n">put</span> <span class="s">"branch B"</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">run</span> <span class="n">p</span>          <span class="o">=</span> <span class="n">runState</span> <span class="p">(</span><span class="n">runParserT</span> <span class="n">p</span> <span class="s">""</span> <span class="s">""</span><span class="p">)</span> <span class="s">"initial"</span>
      <span class="p">(</span><span class="kt">Right</span> <span class="n">a0</span><span class="p">,</span> <span class="n">s0</span><span class="p">)</span> <span class="o">=</span> <span class="n">run</span> <span class="n">parser0</span>
      <span class="p">(</span><span class="kt">Right</span> <span class="n">a1</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span> <span class="o">=</span> <span class="n">run</span> <span class="n">parser1</span>

  <span class="n">putStrLn</span>  <span class="s">"Parser 0"</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Result:      "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a0</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Final state: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s0</span><span class="p">)</span>

  <span class="n">putStrLn</span>  <span class="s">"Parser 1"</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Result:      "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a1</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Final state: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s1</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>这是程序的运行结果：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>Parser 0
Result:      "foo"
Final state: "branch A"
Parser 1
Result:      "branch A"
Final state: "branch B"
</code></pre>
            </div>
          </div>

          <p>
            我们可以看到
            <code class="language-plaintext highlighter-rouge">parser0</code>
            的分支
            <code class="language-plaintext highlighter-rouge">b</code>
            没有被尝试过。而
            <code class="language-plaintext highlighter-rouge">parser1</code>
            的最终结果（<code class="language-plaintext highlighter-rouge"
              >get</code
            >
            返回的值）显然来自分支
            <code class="language-plaintext highlighter-rouge">a</code
            >，即使它因为
            <code class="language-plaintext highlighter-rouge">empty</code>
            而失败了，成功的是分支
            <code class="language-plaintext highlighter-rouge">b</code>（<code
              class="language-plaintext highlighter-rouge"
              >empty</code
            >
            在这里表示立即失败，并且不会提供任何提示信息）。并没有发生回溯。
          </p>

          <p>
            如果我们想要回溯自定义的状态怎么办呢？如果允许将
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            包装在
            <code class="language-plaintext highlighter-rouge">StateT</code>
            里面的话，就可以做到：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">MyStack</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">StateT</span> <span class="kt">MyState</span> <span class="p">(</span><span class="kt">ParsecT</span> <span class="kt">Void</span> <span class="kt">Text</span> <span class="kt">Identity</span><span class="p">)</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            现在我们在
            <code class="language-plaintext highlighter-rouge">MyStack</code>
            上用的
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            作用于
            <code class="language-plaintext highlighter-rouge">StateT</code>
            的实例：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kt">StateT</span> <span class="n">m</span> <span class="o">&lt;|&gt;</span> <span class="kt">StateT</span> <span class="n">n</span> <span class="o">=</span> <span class="kt">StateT</span> <span class="o">$</span> <span class="nf">\</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">s</span> <span class="o">&lt;|&gt;</span> <span class="n">n</span> <span class="n">s</span>
</code></pre>
            </div>
          </div>

          <p>
            它会帮我们回溯状态，并会把剩下的工作委托给内部单子
            <code class="language-plaintext highlighter-rouge">ParsecT</code> 的
            <code class="language-plaintext highlighter-rouge"
              >Alternative</code
            >
            实例。这样的行为就是我们想要的：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Control.Monad.Identity</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State.Strict</span>
<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">State</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">StateT</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">ParsecT</span> <span class="kt">Void</span> <span class="kt">Text</span> <span class="kt">Identity</span><span class="p">)</span>

<span class="n">parser</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">parser</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&lt;|&gt;</span> <span class="n">b</span>
  <span class="kr">where</span>
    <span class="n">a</span> <span class="o">=</span> <span class="s">"foo"</span> <span class="o">&lt;$</span> <span class="n">put</span> <span class="s">"branch A"</span> <span class="o">&lt;*</span> <span class="n">empty</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">get</span>   <span class="o">&lt;*</span> <span class="n">put</span> <span class="s">"branch B"</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="kr">let</span> <span class="n">p</span>            <span class="o">=</span> <span class="n">runStateT</span> <span class="n">parser</span> <span class="s">"initial"</span>
      <span class="kt">Right</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="n">runParser</span> <span class="n">p</span> <span class="s">""</span> <span class="s">""</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Result:      "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">"Final state: "</span> <span class="o">++</span> <span class="n">show</span> <span class="n">s</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>程序输出为：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>Result:      "initial"
Final state: "branch B"
</code></pre>
            </div>
          </div>

          <p>
            为了让这种方法可行，<code
              class="language-plaintext highlighter-rouge"
              >StateT</code
            >
            应当支持所有组合子原语，这样我们就能像
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            一样使用它们。换句话说，它们应当是
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec</code
            >
            的实例，就像它们不仅是
            <code class="language-plaintext highlighter-rouge">MonadState</code>
            的实例，还是
            <code class="language-plaintext highlighter-rouge"
              >MonadWriter</code
            >
            的实例，只要它们的内部单子也是
            <code class="language-plaintext highlighter-rouge"
              >MonadWriter</code
            >
            的实例：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">instance</span> <span class="kt">MonadWriter</span> <span class="n">w</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">MonadWriter</span> <span class="n">w</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span> <span class="err">…</span>
</code></pre>
            </div>
          </div>

          <p>
            实际上，我们可以将原语从
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec</code
            >
            的内部实例提升到
            <code class="language-plaintext highlighter-rouge">StateT</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">instance</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="p">(</span><span class="kt">StateT</span> <span class="n">st</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span> <span class="err">…</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            为所有 MTL 单子变换定义了
            <code class="language-plaintext highlighter-rouge"
              >MonadParsec</code
            >
            的实例，这样用户就可以自由地在
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            中插入单子变换，或是把
            <code class="language-plaintext highlighter-rouge">ParsecT</code>
            包装在那些单子变换中，从而实现在单子栈各层之间的不同交互。
          </p>

          <h2 id="词法分析">词法分析</h2>

          <p>
            词法分析是将输入流转换为词法单词流的过程：整数、关键字、符号等等，它们比原始输入更加容易直接分析，或者可以送作生成的语法分析器的输入。词法分析可以用外部工具（如
            <code class="language-plaintext highlighter-rouge">alex</code
            >）单独一个流程去做，但
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            也提供了可以无缝衔接编写词法分析器的函数。
          </p>

          <p>
            共有两个词法分析器模块：<code
              class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Char.Lexer</code
            >
            用来处理字符流，<code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Byte.Lexer</code
            >
            用来处理字节流。因为我们的输入流是严格求值的
            <code class="language-plaintext highlighter-rouge">Text</code
            >，所以我们会用
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Char.Lexer</code
            >，不过大多数函数在
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Byte.Lexer</code
            >
            里面长得差不多。
          </p>

          <h3 id="空格">空格</h3>

          <p>
            我们要讨论的第一个话题是如何处理空格。在消耗空格的时候保持一致性比较好，即要么在单词前要么在后。<code
              class="language-plaintext highlighter-rouge"
              >megaparsec</code
            >
            的词法分析器模块遵循的策略是：假设单词前没有空格，消耗单词后的空格。
          </p>

          <p>
            我们需要一种特殊的词法分析器来消耗空格，我们叫它空格消耗器。<code
              class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Char.Lexer</code
            >
            模块提供了构建通用的空格消耗器的工具：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">space</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="n">m</span> <span class="nb">()</span> <span class="c1">-- ^ A parser for space characters which does not accept empty input (e.g. 'space1')</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span> <span class="c1">-- ^ A parser for a line comment (e.g. 'skipLineComment')</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span> <span class="c1">-- ^ A parser for a block comment (e.g. 'skipBlockComment')</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">space</code>
            函数的文档挺好理解的，但还是让我们来举例说明吧：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec.Char</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Text.Megaparsec.Char.Lexer</span> <span class="k">as</span> <span class="n">L</span> <span class="c1">-- (1)</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>

<span class="n">sc</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="n">sc</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">space</span>
  <span class="n">space1</span>                         <span class="c1">-- (2)</span>
  <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">skipLineComment</span> <span class="s">"//"</span><span class="p">)</span>       <span class="c1">-- (3)</span>
  <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">skipBlockComment</span> <span class="s">"/*"</span> <span class="s">"*/"</span><span class="p">)</span> <span class="c1">-- (4)</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              (1)
              <code class="language-plaintext highlighter-rouge"
                >Text.Megaparsec.Char.Lexer</code
              >
              应当限定导入，因为它包含会与
              <code class="language-plaintext highlighter-rouge"
                >Text.Megaparsec.Char</code
              >
              等模块冲突的名字，比如
              <code class="language-plaintext highlighter-rouge">space</code>。
            </li>
            <li>
              (2)
              <code class="language-plaintext highlighter-rouge">L.space</code>
              的第一个参数是个挑选空格的词法分析器。要注意它不能接受空输入，否则
              <code class="language-plaintext highlighter-rouge">L.space</code>
              会陷入死循环。<code class="language-plaintext highlighter-rouge"
                >Text.Megaparsec.Char</code
              >
              里的
              <code class="language-plaintext highlighter-rouge">space1</code>
              完美符合要求。
            </li>
            <li>
              (3)
              <code class="language-plaintext highlighter-rouge">L.space</code>
              的第二个参数定义了如何跳过行注释，即以给定单词序列开始、以行末结束的注释。<code
                class="language-plaintext highlighter-rouge"
                >skipLineComment</code
              >
              可以帮我们轻松创建一个这样的词法分析器。
            </li>
            <li>
              (4)
              <code class="language-plaintext highlighter-rouge">L.space</code>
              的第三个参数定义了如何跳过块注释，即包裹在给定的始末单词序列中的注释。<code
                class="language-plaintext highlighter-rouge"
                >skipBlockComment</code
              >
              可以帮我们处理非嵌套的块注释，若要支持嵌套则可使用
              <code class="language-plaintext highlighter-rouge"
                >skipBlockCommentNested</code
              >。
            </li>
          </ul>

          <p>
            操作上，<code class="language-plaintext highlighter-rouge"
              >L.space</code
            >
            会不停地轮流尝试以上三个词法分析器，直到三个都不再消耗空格。如果你的语法不包含注释，那么可以直接把
            <code class="language-plaintext highlighter-rouge">empty</code>
            作为第二或第三个参数送给
            <code class="language-plaintext highlighter-rouge">L.space</code
            >。<code class="language-plaintext highlighter-rouge">empty</code
            >，作为
            <code class="language-plaintext highlighter-rouge"
              >(&lt;|&gt;)</code
            >
            的单位元，仅仅会让
            <code class="language-plaintext highlighter-rouge">L.space</code>
            尝试下一个词法分析器。
          </p>

          <p>
            有了空格消耗器
            <code class="language-plaintext highlighter-rouge">sc</code
            >，我们可以定义各种空格相关的工具：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">lexeme</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="n">lexeme</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">lexeme</span> <span class="n">sc</span>

<span class="n">symbol</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="n">symbol</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">symbol</span> <span class="n">sc</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">lexeme</code>
              是对词汇分析器的一种包装，能用已给定的空格消耗器挑选出所有尾随空格；
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">symbol</code>
              在内部使用
              <code class="language-plaintext highlighter-rouge">string</code>
              来匹配文本，类似地能够挑选出所有的尾随空格。
            </li>
          </ul>

          <p>
            稍后我们将看到它们如何协同工作，但在此之前我们需要引入更多来自
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Char.Lexer</code
            >
            的工具。
          </p>

          <h3 id="字符和字符串字面量">字符和字符串字面量</h3>

          <p>
            对字符和字符串字面量进行词法分析比较微妙，因为有太多转义规则。简单起见，<code
              class="language-plaintext highlighter-rouge"
              >megaparsec</code
            >
            提供了
            <code class="language-plaintext highlighter-rouge"
              >charLiteral</code
            >
            词法分析器：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">charLiteral</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Token</span> <span class="n">s</span> <span class="o">~</span> <span class="kt">Char</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">Char</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >charLiteral</code
            >
            的工作是根据 Haskell
            报告中描述的字符字面量语法来对可能转义了的单个字符进行词法分析。但注意它不会管字面量两边的引号，这有两个原因：
          </p>

          <ul>
            <li>用户可以控制字符字面量用什么作为引号；</li>
            <li>
              <code class="language-plaintext highlighter-rouge"
                >charLiteral</code
              >
              也可以用来对字符串字面量进行词法分析。
            </li>
          </ul>

          <p>
            下面是基于
            <code class="language-plaintext highlighter-rouge"
              >charLiteral</code
            >
            构建词法分析器的例子：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">charLiteral</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Char</span>
<span class="n">charLiteral</span> <span class="o">=</span> <span class="n">between</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'</span><span class="se">\'</span><span class="sc">'</span><span class="p">)</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'</span><span class="se">\'</span><span class="sc">'</span><span class="p">)</span> <span class="kt">L</span><span class="o">.</span><span class="n">charLiteral</span>

<span class="n">stringLiteral</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">stringLiteral</span> <span class="o">=</span> <span class="n">char</span> <span class="sc">'</span><span class="se">\"</span><span class="sc">'</span> <span class="o">*&gt;</span> <span class="n">manyTill</span> <span class="kt">L</span><span class="o">.</span><span class="n">charLiteral</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'</span><span class="se">\"</span><span class="sc">'</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              要把
              <code class="language-plaintext highlighter-rouge"
                >L.charLiteral</code
              >
              改造成我们所需的字符字面量的词法分析器，只需要加上两边的引号。这里我们遵循
              Haskell 语法用了单引号。<code
                class="language-plaintext highlighter-rouge"
                >between</code
              >
              组合子是这样定义的：<code
                class="language-plaintext highlighter-rouge"
                >between open close p = open *&gt; p &lt;* close</code
              >。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge"
                >stringLiteral</code
              >
              用
              <code class="language-plaintext highlighter-rouge"
                >L.charLiteral</code
              >
              来对每个字符进行词法分析，两边则用双引号包裹。
            </li>
          </ul>

          <p>
            第二个函数也很有趣，因为它用了
            <code class="language-plaintext highlighter-rouge">manyTill</code>
            组合子：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">manyTill</span> <span class="o">::</span> <span class="kt">Alternative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">end</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">manyTill</span> <span class="n">p</span> <span class="n">end</span> <span class="o">=</span> <span class="n">go</span>
  <span class="kr">where</span>
    <span class="n">go</span> <span class="o">=</span> <span class="p">(</span><span class="kt">[]</span> <span class="o">&lt;$</span> <span class="n">end</span><span class="p">)</span> <span class="o">&lt;|&gt;</span> <span class="p">((</span><span class="o">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">p</span> <span class="o">&lt;*&gt;</span> <span class="n">go</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            每一轮
            <code class="language-plaintext highlighter-rouge">manyTill</code>
            先尝试运行
            <code class="language-plaintext highlighter-rouge">end</code>
            词法分析器，如果失败了就运行
            <code class="language-plaintext highlighter-rouge">p</code>
            并把结果装进列表。也有
            <code class="language-plaintext highlighter-rouge">someTill</code>
            保证
            <code class="language-plaintext highlighter-rouge">p</code>
            至少成功一次。
          </p>

          <h3 id="数字">数字</h3>

          <p>
            最后，一个非常常见的需求是对数字进行词法分析。对于整数来说，有三种工具分别处理十进制、八进制和十六进制数：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">decimal</span><span class="p">,</span> <span class="n">octal</span><span class="p">,</span> <span class="n">hexadecimal</span>
  <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Token</span> <span class="n">s</span> <span class="o">~</span> <span class="kt">Char</span><span class="p">,</span> <span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>使用起来很简单：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">integer</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Integer</span>
<span class="n">integer</span> <span class="o">=</span> <span class="n">lexeme</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span>
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (integer &lt;* eof) "123  "
123
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (integer &lt;* eof) "12a  "
1:3:
  |
1 | 12a
  |   ^
unexpected 'a'
expecting end of input or the rest of integer
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">scientific</code>
            接受整数和小数的语法，而
            <code class="language-plaintext highlighter-rouge">float</code>
            只接受小数。<code class="language-plaintext highlighter-rouge"
              >scientific</code
            >
            会返回
            <code class="language-plaintext highlighter-rouge">scientific</code>
            包的
            <code class="language-plaintext highlighter-rouge">Scientific</code>
            类型，而
            <code class="language-plaintext highlighter-rouge">float</code>
            的返回类型是多态的，可能会返回任何
            <code class="language-plaintext highlighter-rouge">RealFloat</code>
            的实例：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">scientific</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Token</span> <span class="n">s</span> <span class="o">~</span> <span class="kt">Char</span><span class="p">)</span>              <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">Scientific</span>
<span class="n">float</span>      <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Token</span> <span class="n">s</span> <span class="o">~</span> <span class="kt">Char</span><span class="p">,</span> <span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>举个例子：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">float</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Double</span>
<span class="n">float</span> <span class="o">=</span> <span class="n">lexeme</span> <span class="kt">L</span><span class="o">.</span><span class="n">float</span>
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (float &lt;* eof) "123"
1:4:
  |
1 | 123
  |    ^
unexpected end of input
expecting '.', 'E', 'e', or digit
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (float &lt;* eof) "123.45"
123.45
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (float &lt;* eof) "123d"
1:4:
  |
1 | 123d
  |    ^
unexpected 'd'
expecting '.', 'E', 'e', or digit
</code></pre>
            </div>
          </div>

          <p>
            注意所有这些词法分析器都无法处理有符号数，要支持这个我们得把它们包装在
            <code class="language-plaintext highlighter-rouge">signed</code>
            组合子中：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">signedInteger</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Integer</span>
<span class="n">signedInteger</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">signed</span> <span class="n">sc</span> <span class="n">integer</span>

<span class="n">signedFloat</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Double</span>
<span class="n">signedFloat</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">signed</span> <span class="n">sc</span> <span class="n">float</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">signed</code>
            的第一个参数是空格消耗器，用来控制正负号和实际数字之间的空格。如果你不允许中间有空格，传
            <code class="language-plaintext highlighter-rouge">return ()</code>
            进去就行了。
          </p>

          <h2 id="notfollowedby-和-lookahead">
            <code class="language-plaintext highlighter-rouge"
              >notFollowedBy</code
            >
            和
            <code class="language-plaintext highlighter-rouge">lookAhead</code>
          </h2>

          <p>
            除了
            <code class="language-plaintext highlighter-rouge">try</code
            >，还有另外两种原语可以对输入流进行前瞻，而不会实际挪动当前位置。
          </p>

          <p>
            第一种是
            <code class="language-plaintext highlighter-rouge"
              >notFollowedBy</code
            >：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">notFollowedBy</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</code></pre>
            </div>
          </div>

          <p>
            只有当其参数语法分析失败了它才会成功，并且不会吃掉任何输入或是修改当前状态。
          </p>

          <p>
            作为
            <code class="language-plaintext highlighter-rouge"
              >notFollowedBy</code
            >
            的例子，我们考虑一下关键字：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pKeyword</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="n">pKeyword</span> <span class="n">keyword</span> <span class="o">=</span> <span class="n">lexeme</span> <span class="p">(</span><span class="n">string</span> <span class="n">keyword</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            这个语法分析器有个毛病：如果我们匹配到的只是标识符的前缀怎么办呢？这个情况下它显然不是关键字。因此我们必须用
            <code class="language-plaintext highlighter-rouge"
              >notFollowedBy</code
            >
            排除这种情况：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pKeyword</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">Text</span>
<span class="n">pKeyword</span> <span class="n">keyword</span> <span class="o">=</span> <span class="n">lexeme</span> <span class="p">(</span><span class="n">string</span> <span class="n">keyword</span> <span class="o">&lt;*</span> <span class="n">notFollowedBy</span> <span class="n">alphaNumChar</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            另一种原语是
            <code class="language-plaintext highlighter-rouge">lookAhead</code
            >：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">lookAhead</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            如果
            <code class="language-plaintext highlighter-rouge">lookAhead</code>
            的参数
            <code class="language-plaintext highlighter-rouge">p</code>
            成功了，那么整个
            <code class="language-plaintext highlighter-rouge"
              >lookAhead p</code
            >
            也会成功，但输入流和整个语法分析状态不会改变。
          </p>

          <p>
            一个例子是对已分析的输入进行检查，要么失败要么成功地进行下去。这可以用下述代码表达：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">withPredicate1</span>
  <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>       <span class="c1">-- ^ The check to perform on parsed input</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>            <span class="c1">-- ^ Message to print when the check fails</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Resulting parser that performs the check</span>
<span class="n">withPredicate1</span> <span class="n">f</span> <span class="n">msg</span> <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">lookAhead</span> <span class="n">p</span>
  <span class="kr">if</span> <span class="n">f</span> <span class="n">r</span>
    <span class="kr">then</span> <span class="n">p</span>
    <span class="kr">else</span> <span class="n">fail</span> <span class="n">msg</span>
</code></pre>
            </div>
          </div>

          <p>
            这演示了
            <code class="language-plaintext highlighter-rouge">lookAhead</code>
            的一种用法，但我们还应注意，如果检查成功我们会进行两次语法分析，这不太好。我们可以改用
            <code class="language-plaintext highlighter-rouge">getOffset</code>
            函数解决这个问题：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">withPredicate2</span>
  <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>       <span class="c1">-- ^ The check to perform on parsed input</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>            <span class="c1">-- ^ Message to print when the check fails</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Resulting parser that performs the check</span>
<span class="n">withPredicate2</span> <span class="n">f</span> <span class="n">msg</span> <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">o</span> <span class="o">&lt;-</span> <span class="n">getOffset</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">p</span>
  <span class="kr">if</span> <span class="n">f</span> <span class="n">r</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">r</span>
    <span class="kr">else</span> <span class="kr">do</span>
      <span class="n">setOffset</span> <span class="n">o</span>
      <span class="n">fail</span> <span class="n">msg</span>
</code></pre>
            </div>
          </div>

          <p>
            在失败时，我们只需将输入流的偏移量设置回运行
            <code class="language-plaintext highlighter-rouge">p</code>
            之前的位置即可。但现在消耗量跟偏移量会不匹配，但在这里没有关系，因为我们调用
            <code class="language-plaintext highlighter-rouge">fail</code>
            立即结束了语法分析。但这在其它地方可能会出问题，我们将在后面的章节中看到如何改进。
          </p>

          <h2 id="表达式的语法分析">表达式的语法分析</h2>

          <p>
            「表达式」是指由一些项和应用于这些项的运算符组成的结构。运算符可以前置、中置、后置，可以左结合、右结合，可以有不同的优先级。这种构造的一个例子是学校里教的算术表达式：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>a * (b + 2)
</code></pre>
            </div>
          </div>

          <p>
            这里我们可以看到两种不同的项：变量（<code
              class="language-plaintext highlighter-rouge"
              >a</code
            >、<code class="language-plaintext highlighter-rouge">b</code
            >）和整数（<code class="language-plaintext highlighter-rouge"
              >2</code
            >）。另外还有两种运算符：<code
              class="language-plaintext highlighter-rouge"
              >*</code
            >
            和 <code class="language-plaintext highlighter-rouge">+</code>。
          </p>

          <p>
            为表达式编写一个正确的语法分析器大概需要假以时日。为此，<a
              href="https://hackage.haskell.org/package/parser-combinators"
              >parser-combinators</a
            >
            包提供了
            <code class="language-plaintext highlighter-rouge"
              >Control.Monad.Combinators.Expr</code
            >
            模块，它一共导出了两样东西：<code
              class="language-plaintext highlighter-rouge"
              >Operator</code
            >
            数据类型和
            <code class="language-plaintext highlighter-rouge"
              >makeExprParser</code
            >
            工具函数。两者均文档齐全，所以本节我们不会复述文档，而是编写一个简单但功能完备的表达式语法分析器。
          </p>

          <p>让我们先定义一个表示抽象语法树的数据结构：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">Expr</span>
  <span class="o">=</span> <span class="kt">Var</span> <span class="kt">String</span>
  <span class="o">|</span> <span class="kt">Int</span> <span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Negation</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">Sum</span>      <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">Subtr</span>    <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">Product</span>  <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="o">|</span> <span class="kt">Division</span> <span class="kt">Expr</span> <span class="kt">Expr</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            要用
            <code class="language-plaintext highlighter-rouge"
              >makeExprParser</code
            >
            我们得给它一个项语法分析器和一个运算符表：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">makeExprParser</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span>               <span class="c1">-- ^ Term parser</span>
  <span class="o">-&gt;</span> <span class="p">[[</span><span class="kt">Operator</span> <span class="n">m</span> <span class="n">a</span><span class="p">]]</span>  <span class="c1">-- ^ Operator table, see 'Operator'</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>               <span class="c1">-- ^ Resulting expression parser</span>
</code></pre>
            </div>
          </div>

          <p>
            让我们从项语法分析器开始。我们可以把项视为一个盒子，当处理结合性和优先级之类的东西时，表达式的语法分析算法会将其视为不可分割的整体。在我们例子中，有三类东西属于项：变量、整数和括号中的整个表达式。沿用前面几章节的定义，我们可以把项语法分析器定义为：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pVariable</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Expr</span>
<span class="n">pVariable</span> <span class="o">=</span> <span class="kt">Var</span> <span class="o">&lt;$&gt;</span> <span class="n">lexeme</span>
  <span class="p">((</span><span class="o">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">letterChar</span> <span class="o">&lt;*&gt;</span> <span class="n">many</span> <span class="n">alphaNumChar</span> <span class="o">&lt;?&gt;</span> <span class="s">"variable"</span><span class="p">)</span>

<span class="n">pInteger</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Expr</span>
<span class="n">pInteger</span> <span class="o">=</span> <span class="kt">Int</span> <span class="o">&lt;$&gt;</span> <span class="n">lexeme</span> <span class="kt">L</span><span class="o">.</span><span class="n">decimal</span>

<span class="n">parens</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="n">parens</span> <span class="o">=</span> <span class="n">between</span> <span class="p">(</span><span class="n">symbol</span> <span class="s">"("</span><span class="p">)</span> <span class="p">(</span><span class="n">symbol</span> <span class="s">")"</span><span class="p">)</span>

<span class="n">pTerm</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Expr</span>
<span class="n">pTerm</span> <span class="o">=</span> <span class="n">choice</span>
  <span class="p">[</span> <span class="n">parens</span> <span class="n">pExpr</span>
  <span class="p">,</span> <span class="n">pVariable</span>
  <span class="p">,</span> <span class="n">pInteger</span>
  <span class="p">]</span>

<span class="n">pExpr</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Expr</span>
<span class="n">pExpr</span> <span class="o">=</span> <span class="n">makeExprParser</span> <span class="n">pTerm</span> <span class="n">operatorTable</span>

<span class="n">operatorTable</span> <span class="o">::</span> <span class="p">[[</span><span class="kt">Operator</span> <span class="kt">Parser</span> <span class="kt">Expr</span><span class="p">]]</span>
<span class="n">operatorTable</span> <span class="o">=</span> <span class="n">undefined</span> <span class="c1">-- TODO</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">pVariable</code
            >、<code class="language-plaintext highlighter-rouge"
              >pInteger</code
            >
            和
            <code class="language-plaintext highlighter-rouge">parens</code>
            的定义应该没什么疑问。这里幸运的是我们不需要在
            <code class="language-plaintext highlighter-rouge">pTerm</code>
            中使用
            <code class="language-plaintext highlighter-rouge">try</code
            >，因为项的语法没有重叠之处：
          </p>

          <ul>
            <li>
              如果我们看到左括号
              <code class="language-plaintext highlighter-rouge">(</code
              >，那紧接着肯定是一个表达式；
            </li>
            <li>如果我们看到一个字母，那肯定是标识符的开始；</li>
            <li>如果我们看到一个数字，那肯定是整数的开始。</li>
          </ul>

          <p>
            最后，为了完成
            <code class="language-plaintext highlighter-rouge">pExpr</code
            >，我们需要定义
            <code class="language-plaintext highlighter-rouge"
              >operatorTable</code
            >，从类型可以看出它是个嵌套列表。每个内层列表装着相同优先级的运算符，而整个外层列表以优先级降序排列。一组运算符的优先级越高，它们结合得就越紧。
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">Operator</span> <span class="n">m</span> <span class="n">a</span> <span class="c1">-- N.B.</span>
  <span class="o">=</span> <span class="kt">InfixN</span>  <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">))</span> <span class="c1">-- ^ Non-associative infix</span>
  <span class="o">|</span> <span class="kt">InfixL</span>  <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">))</span> <span class="c1">-- ^ Left-associative infix</span>
  <span class="o">|</span> <span class="kt">InfixR</span>  <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">))</span> <span class="c1">-- ^ Right-associative infix</span>
  <span class="o">|</span> <span class="kt">Prefix</span>  <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">))</span>      <span class="c1">-- ^ Prefix</span>
  <span class="o">|</span> <span class="kt">Postfix</span> <span class="p">(</span><span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="p">))</span>      <span class="c1">-- ^ Postfix</span>

<span class="n">operatorTable</span> <span class="o">::</span> <span class="p">[[</span><span class="kt">Operator</span> <span class="kt">Parser</span> <span class="kt">Expr</span><span class="p">]]</span>
<span class="n">operatorTable</span> <span class="o">=</span>
  <span class="p">[</span> <span class="p">[</span> <span class="n">prefix</span> <span class="s">"-"</span> <span class="kt">Negation</span>
    <span class="p">,</span> <span class="n">prefix</span> <span class="s">"+"</span> <span class="n">id</span>
    <span class="p">]</span>
  <span class="p">,</span> <span class="p">[</span> <span class="n">binary</span> <span class="s">"*"</span> <span class="kt">Product</span>
    <span class="p">,</span> <span class="n">binary</span> <span class="s">"/"</span> <span class="kt">Division</span>
    <span class="p">]</span>
  <span class="p">,</span> <span class="p">[</span> <span class="n">binary</span> <span class="s">"+"</span> <span class="kt">Sum</span>
    <span class="p">,</span> <span class="n">binary</span> <span class="s">"-"</span> <span class="kt">Subtr</span>
    <span class="p">]</span>
  <span class="p">]</span>

<span class="n">binary</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Expr</span> <span class="o">-&gt;</span> <span class="kt">Expr</span> <span class="o">-&gt;</span> <span class="kt">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Operator</span> <span class="kt">Parser</span> <span class="kt">Expr</span>
<span class="n">binary</span>  <span class="n">name</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">InfixL</span>  <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$</span> <span class="n">symbol</span> <span class="n">name</span><span class="p">)</span>

<span class="n">prefix</span><span class="p">,</span> <span class="n">postfix</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Expr</span> <span class="o">-&gt;</span> <span class="kt">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Operator</span> <span class="kt">Parser</span> <span class="kt">Expr</span>
<span class="n">prefix</span>  <span class="n">name</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Prefix</span>  <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$</span> <span class="n">symbol</span> <span class="n">name</span><span class="p">)</span>
<span class="n">postfix</span> <span class="n">name</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Postfix</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$</span> <span class="n">symbol</span> <span class="n">name</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            注意
            <code class="language-plaintext highlighter-rouge">binary</code> 中
            <code class="language-plaintext highlighter-rouge">InfixL</code>
            接受的
            <code class="language-plaintext highlighter-rouge"
              >Parser (Expr -&gt; Expr -&gt; Expr)</code
            >
            我们是怎么写的，相似的还有
            <code class="language-plaintext highlighter-rouge">prefix</code> 和
            <code class="language-plaintext highlighter-rouge">postfix</code>
            中的
            <code class="language-plaintext highlighter-rouge"
              >Parser (Expr -&gt; Expr)</code
            >。也就是说，我们先运行
            <code class="language-plaintext highlighter-rouge"
              >symbol name</code
            >
            然后返回一个函数，它会依次接受各项作为参数并返回
            <code class="language-plaintext highlighter-rouge">Expr</code>
            类型的结果。
          </p>

          <p>准备好了，现在可以试试我们的语法分析器了！</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pExpr &lt;* eof) "a * (b + 2)"
Product (Var "a") (Sum (Var "b") (Int 2))
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pExpr &lt;* eof) "a * b + 2"
Sum (Product (Var "a") (Var "b")) (Int 2)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pExpr &lt;* eof) "a * b / 2"
Division (Product (Var "a") (Var "b")) (Int 2)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pExpr &lt;* eof) "a * (b $ 2)"
1:8:
  |
1 | a * (b $ 2)
  |        ^
unexpected '$'
expecting ')' or operator
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >Control.Monad.Combinators.Expr</code
            >
            模块的文档里有一些提示，在不太标准的情况下很有用，最好也读一下。
          </p>

          <h2 id="缩进敏感的语法分析">缩进敏感的语法分析</h2>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Char.Lexer</code
            >
            模块还包含一些工具，在处理对缩进敏感的语法时很有用。我们会先综述一下可用的组合子，然后再把它们组装成一个对缩进敏感的语法分析器。
          </p>

          <h3 id="nonindented-和-indentblock">
            <code class="language-plaintext highlighter-rouge"
              >nonIndented</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >indentBlock</code
            >
          </h3>

          <p>
            让我们从最简单的
            <code class="language-plaintext highlighter-rouge"
              >nonIndented</code
            >
            开始：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">nonIndented</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="n">m</span> <span class="nb">()</span>              <span class="c1">-- ^ How to consume indentation (white space)</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>               <span class="c1">-- ^ Inner parser</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            它允许内部语法分析器吃掉所有没缩进的输入，这是缩进敏感语法分析背后模型的一部分。我们规定，未缩进的部分是顶层定义，而所有缩进的部分直接或间接地从属于顶层定义。在
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            中，我们不需要任何额外的状态来表达这个想法。因为缩进是相对的，所以我们的想法是显式地把参考单词和缩进单词都传给语法分析器，这样就能通过纯的语法分析器组合来定义对缩进敏感的语法。
          </p>

          <p>
            那么我们应当如何为缩进块定义语法分析器呢？让我们看一眼
            <code class="language-plaintext highlighter-rouge"
              >indentBlock</code
            >
            的签名：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">indentBlock</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Token</span> <span class="n">s</span> <span class="o">~</span> <span class="kt">Char</span><span class="p">)</span>
  <span class="o">=&gt;</span> <span class="n">m</span> <span class="nb">()</span>                <span class="c1">-- ^ How to consume indentation (white space)</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">IndentOpt</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="c1">-- ^ How to parse “reference” token</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            首先，我们指定如何吃掉缩进。要注意的是这里的空格消耗器必须也吃掉换行符，但正常来讲单词后面的换行符是不应该吃掉的。
          </p>

          <p>
            如你所见，第二个参数允许我们对参考单词进行语法分析，并返回一个告诉
            <code class="language-plaintext highlighter-rouge"
              >indentBlock</code
            >
            接下来做什么的数据结构。下面是几种选择：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">IndentOpt</span> <span class="n">m</span> <span class="n">a</span> <span class="n">b</span>
  <span class="o">=</span> <span class="kt">IndentNone</span> <span class="n">a</span>
    <span class="c1">-- ^ Parse no indented tokens, just return the value</span>
  <span class="o">|</span> <span class="kt">IndentMany</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Pos</span><span class="p">)</span> <span class="p">([</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">b</span><span class="p">)</span>
    <span class="c1">-- ^ Parse many indented tokens (possibly zero), use given indentation level</span>
    <span class="c1">-- (if 'Nothing', use level of the first indented token);</span>
    <span class="c1">-- the second argument tells how to get the final result, and</span>
    <span class="c1">-- the third argument describes how to parse an indented token</span>
  <span class="o">|</span> <span class="kt">IndentSome</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Pos</span><span class="p">)</span> <span class="p">([</span><span class="n">b</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span> <span class="n">b</span><span class="p">)</span>
    <span class="c1">-- ^ Just like 'IndentMany', but requires at least one indented token to be present</span>
</code></pre>
            </div>
          </div>

          <p>
            我们可以改变主意不对缩进单词进行语法分析，也可以处理许多缩进单词。我们可以让
            <code class="language-plaintext highlighter-rouge"
              >indentBlock</code
            >
            检测首个缩进单词的缩进层级并使用它，也可以手动指定缩进层级。
          </p>

          <h3 id="简单的缩进列表">简单的缩进列表</h3>

          <p>
            让我们试着对一个简单的缩进列表进行语法分析，我们从导入部分开始：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="cp">{-# LANGUAGE TupleSections     #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">void</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec.Char</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Text.Megaparsec.Char.Lexer</span> <span class="k">as</span> <span class="n">L</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>
</code></pre>
            </div>
          </div>

          <p>
            我们需要两种空格消耗器：一种
            <code class="language-plaintext highlighter-rouge">scn</code>
            会吃掉换行符，另一种
            <code class="language-plaintext highlighter-rouge">sc</code>
            不会（实际上在这里它只处理空格和制表符）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">lineComment</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="n">lineComment</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">skipLineComment</span> <span class="s">"#"</span>

<span class="n">scn</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="n">scn</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">space</span> <span class="n">space1</span> <span class="n">lineComment</span> <span class="n">empty</span>

<span class="n">sc</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="n">sc</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">space</span> <span class="p">(</span><span class="n">void</span> <span class="o">$</span> <span class="n">some</span> <span class="p">(</span><span class="n">char</span> <span class="sc">' '</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'</span><span class="se">\t</span><span class="sc">'</span><span class="p">))</span> <span class="n">lineComment</span> <span class="n">empty</span>

<span class="n">lexeme</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="n">lexeme</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">lexeme</span> <span class="n">sc</span>
</code></pre>
            </div>
          </div>

          <p>
            为了好玩，我们还允许
            <code class="language-plaintext highlighter-rouge">#</code>
            开头的行注释。
          </p>

          <p>
            <code class="language-plaintext highlighter-rouge">pItemList</code>
            是顶层形式，它包括参考单词（表头）和缩进单词（表项）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pItemList</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="c1">-- header and list items</span>
<span class="n">pItemList</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">nonIndented</span> <span class="n">scn</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">indentBlock</span> <span class="n">scn</span> <span class="n">p</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">header</span> <span class="o">&lt;-</span> <span class="n">pItem</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">IndentMany</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">))</span> <span class="n">pItem</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>对于我们来讲，表项就是一串字母、数字和短横线组成的序列：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pItem</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">pItem</span> <span class="o">=</span> <span class="n">lexeme</span> <span class="p">(</span><span class="n">some</span> <span class="p">(</span><span class="n">alphaNumChar</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'-'</span><span class="p">))</span> <span class="o">&lt;?&gt;</span> <span class="s">"list item"</span>
</code></pre>
            </div>
          </div>

          <p>
            让我们将代码载入到 GHCi，用内置的
            <code class="language-plaintext highlighter-rouge">parseTest</code>
            试试：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) ""
1:1:
  |
1 | &lt;empty line&gt;
  | ^
unexpected end of input
expecting list item
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something"
("something",[])
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "  something"
1:3:
  |
1 |   something
  |   ^
incorrect indentation (got 3, should be equal to 1)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\none\ntwo\nthree"
2:1:
  |
2 | one
  | ^
unexpected 'o'
expecting end of input
</code></pre>
            </div>
          </div>

          <p>
            记住我们用的是
            <code class="language-plaintext highlighter-rouge">IndentMany</code>
            选项，所以空列表是可以的。另一方面，内置的
            <code class="language-plaintext highlighter-rouge">space</code>
            组合子已在错误信息中隐藏了「expecting more
            space」，所以现在的错误信息是完全合理的。
          </p>

          <p>让我们继续试试：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\n  one\n    two\n  three"
3:5:
  |
3 |     two
  |     ^
incorrect indentation (got 5, should be equal to 3)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\n  one\n  two\n three"
4:2:
  |
4 |  three
  |  ^
incorrect indentation (got 2, should be equal to 3)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\n  one\n  two\n  three"
("something",["one","two","three"])
</code></pre>
            </div>
          </div>

          <p>
            让我们把
            <code class="language-plaintext highlighter-rouge">IndentMany</code>
            换成
            <code class="language-plaintext highlighter-rouge">IndentSome</code
            >，把
            <code class="language-plaintext highlighter-rouge">Nothing</code>
            换成
            <code class="language-plaintext highlighter-rouge"
              >Just (mkPos 5)</code
            >（缩进层级从 1 开始数，所以这表示需要 4 个空格的缩进）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pItemList</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
<span class="n">pItemList</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">nonIndented</span> <span class="n">scn</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">indentBlock</span> <span class="n">scn</span> <span class="n">p</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">header</span> <span class="o">&lt;-</span> <span class="n">pItem</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">IndentSome</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="n">mkPos</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">))</span> <span class="n">pItem</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>现在：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\n"
2:1:
  |
2 | &lt;empty line&gt;
  | ^
incorrect indentation (got 1, should be greater than 1)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\n  one"
2:3:
  |
2 |   one
  |   ^
incorrect indentation (got 3, should be equal to 5)
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pItemList &lt;* eof) "something\n    one"
("something",["one"])
</code></pre>
            </div>
          </div>

          <p>
            第一条错误信息可能有点令人惊讶，但
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            知道列表里至少得有一项，所以它检查了缩进层级发现是
            1，于是报告了错误。
          </p>

          <h3 id="嵌套缩进列表">嵌套缩进列表</h3>

          <p>
            让我们允许表项拥有子项，为此我们创建了一个新的语法分析器
            <code class="language-plaintext highlighter-rouge"
              >pComplexItem</code
            >：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pComplexItem</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
<span class="n">pComplexItem</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">indentBlock</span> <span class="n">scn</span> <span class="n">p</span>
  <span class="kr">where</span>
    <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">header</span> <span class="o">&lt;-</span> <span class="n">pItem</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">IndentMany</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">))</span> <span class="n">pItem</span><span class="p">)</span>

<span class="n">pItemList</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])])</span>
<span class="n">pItemList</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">nonIndented</span> <span class="n">scn</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="n">indentBlock</span> <span class="n">scn</span> <span class="n">p</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">header</span> <span class="o">&lt;-</span> <span class="n">pItem</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">IndentSome</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">))</span> <span class="n">pComplexItem</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>如果我们把下面这样的列表喂进去：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>first-chapter
  paragraph-one
      note-A # an important note here!
      note-B
  paragraph-two
    note-1
    note-2
  paragraph-three
</code></pre>
            </div>
          </div>

          <p>那我们的语法分析器会返回：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>Right
  ( "first-chapter"
  , [ ("paragraph-one",   ["note-A","note-B"])
    , ("paragraph-two",   ["note-1","note-2"])
    , ("paragraph-three", [])
    ]
  )
</code></pre>
            </div>
          </div>

          <p>
            以上演示了这个方法是如何扩展到嵌套缩进结构上的，我们并没有引入额外的状态。
          </p>

          <h3 id="加入折行">加入折行</h3>

          <p>
            「折行」可以包含多行元素，不过后续元素的缩进层级必须高于首个元素。
          </p>

          <p>
            让我们来试用一下
            <code class="language-plaintext highlighter-rouge">lineFold</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pComplexItem</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span>
<span class="n">pComplexItem</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">indentBlock</span> <span class="n">scn</span> <span class="n">p</span>
  <span class="kr">where</span>
    <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
      <span class="n">header</span> <span class="o">&lt;-</span> <span class="n">pItem</span>
      <span class="n">return</span> <span class="p">(</span><span class="kt">L</span><span class="o">.</span><span class="kt">IndentMany</span> <span class="kt">Nothing</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="p">))</span> <span class="n">pLineFold</span><span class="p">)</span>

<span class="n">pLineFold</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">pLineFold</span> <span class="o">=</span> <span class="kt">L</span><span class="o">.</span><span class="n">lineFold</span> <span class="n">scn</span> <span class="o">$</span> <span class="nf">\</span><span class="n">sc'</span> <span class="o">-&gt;</span>
  <span class="kr">let</span> <span class="n">ps</span> <span class="o">=</span> <span class="n">some</span> <span class="p">(</span><span class="n">alphaNumChar</span> <span class="o">&lt;|&gt;</span> <span class="n">char</span> <span class="sc">'-'</span><span class="p">)</span> <span class="p">`</span><span class="n">sepBy1</span><span class="p">`</span> <span class="n">try</span> <span class="n">sc'</span>
  <span class="kr">in</span> <span class="n">unwords</span> <span class="o">&lt;$&gt;</span> <span class="n">ps</span> <span class="o">&lt;*</span> <span class="n">scn</span> <span class="c1">-- (1)</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">lineFold</code>
            的工作方式是：我们先给它一个接受换行符的空格消耗器
            <code class="language-plaintext highlighter-rouge">scn</code
            >，然后它还回来一个特殊的空格消耗器
            <code class="language-plaintext highlighter-rouge">sc'</code
            >，让我们能够在回调中吃掉折行元素之间的空格。
          </p>

          <p>
            为什么 (1) 处要用
            <code class="language-plaintext highlighter-rouge">try sc'</code> 和
            <code class="language-plaintext highlighter-rouge">scn</code>
            呢？情况是这样的：
          </p>

          <ul>
            <li>折行元素只会比首个元素缩进更多。</li>
            <li>
              <code class="language-plaintext highlighter-rouge">sc'</code>
              吃掉空格（也会吃换行符）之后，该列应该比起始列更大。
            </li>
            <li>
              相反，如果吃掉空格后该列小于等于起始列，<code
                class="language-plaintext highlighter-rouge"
                >sc'</code
              >
              会停下来。它失败时不会吃掉任何输入（感谢
              <code class="language-plaintext highlighter-rouge">try</code
              >），<code class="language-plaintext highlighter-rouge">scn</code>
              会被用来挑选空格。
            </li>
            <li>
              前面使用的
              <code class="language-plaintext highlighter-rouge">sc'</code>
              已利用会吃换行符的空格消耗器来探测空格，所以它逻辑上也会在挑选尾随空格时吃掉换行符。这就是为什么我们在
              (1) 处用
              <code class="language-plaintext highlighter-rouge">scn</code>
              而不用
              <code class="language-plaintext highlighter-rouge">sc</code>。
            </li>
          </ul>

          <p>
            【练习】我们语法分析器的最终版本留给读者做测试。你可以创建多个折行元素，语法分析之后它们会用一个空格拼接在一起。
          </p>

          <h2 id="编写高效的语法分析器">编写高效的语法分析器</h2>

          <p>
            让我们讨论一下怎么才能提高
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            语法分析器的性能。不过首先要指出，我们应当用性能分析和基准测试来验证我们的改进。这是我们在性能调优时检查是否有效的唯一方法。
          </p>

          <p>这里有一些常见的建议：</p>

          <ul>
            <li>
              如果你的语法分析器用的是单子栈而非普通的
              <code class="language-plaintext highlighter-rouge">Parsec</code>
              单子（回忆一下，这是使用
              <code class="language-plaintext highlighter-rouge">Identity</code>
              的
              <code class="language-plaintext highlighter-rouge">ParsecT</code>
              单子变换，非常轻量），请确保
              <code class="language-plaintext highlighter-rouge"
                >transformers</code
              >
              库的版本不低于 0.5，<code
                class="language-plaintext highlighter-rouge"
                >megaparsec</code
              >
              的版本不低于
              7.0。这两个库在上述版本均有关键性的性能提升，只要升级就能变快。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">Parsec</code>
              单子总是比基于
              <code class="language-plaintext highlighter-rouge">ParsecT</code>
              的单子变换更快。除非绝对必要，请避免使用
              <code class="language-plaintext highlighter-rouge">StateT</code
              >、<code class="language-plaintext highlighter-rouge"
                >WriterT</code
              >
              或者其它单子变换。往单子栈里加得越多，语法分析就越慢。
            </li>
            <li>
              回溯是个代价高昂的操作。请避免构建冗长的选择链，其中的每个选择都有可能在失败前陷得很深。
            </li>
            <li>
              除非确实有理由，请避免让语法分析器保持多态。最好指定一下语法分析器的具体类型，比如
              <code class="language-plaintext highlighter-rouge"
                >type Parser = Parsec Void Text</code
              >。这样能让 GHC 更好地进行优化。
            </li>
            <li>
              尽可能内联（当然，是在合理的地方）。内联的巨大作用可能会令你难以置信，特别是对于那些很短的函数。这对跨模块使用的语法分析器尤其有用，因为
              <code class="language-plaintext highlighter-rouge">INLINE</code>
              和
              <code class="language-plaintext highlighter-rouge"
                >INLINEABLE</code
              >
              编译指令能让 GHC 把函数定义转储到接口文件，这有助于进行特化。
            </li>
            <li>
              尽可能使用快速的原语，比如
              <code class="language-plaintext highlighter-rouge"
                >takeWhileP</code
              >、<code class="language-plaintext highlighter-rouge"
                >takeWhile1P</code
              >
              和
              <code class="language-plaintext highlighter-rouge">takeP</code
              >。<a
                href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html#there-is-hope"
                >这篇博客</a
              >解释了为什么它们这么快。
            </li>
            <li>
              尽可能使用
              <code class="language-plaintext highlighter-rouge">satisfy</code>
              和
              <code class="language-plaintext highlighter-rouge">notChar</code
              >，而不要使用
              <code class="language-plaintext highlighter-rouge">oneOf</code> 和
              <code class="language-plaintext highlighter-rouge">noneOf</code>。
            </li>
          </ul>

          <p>
            尽量上面大多数建议不需要进一步解释，但我觉得最好养成习惯使用这三个新的原语：<code
              class="language-plaintext highlighter-rouge"
              >takeWhileP</code
            >、<code class="language-plaintext highlighter-rouge"
              >takeWhile1P</code
            >
            和
            <code class="language-plaintext highlighter-rouge">takeP</code
            >。前两个尤其常见，能帮我们替换掉一些基于
            <code class="language-plaintext highlighter-rouge">many</code> 和
            <code class="language-plaintext highlighter-rouge">some</code>
            的结构，它们更快并且会改而返回一大块输入流，也就是我们之前说的
            <code class="language-plaintext highlighter-rouge">Tokens s</code>
            类型。
          </p>

          <p>
            举例来说，回忆一下我们对 URI 的用户名进行语法分析时用到下面的代码：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>  <span class="n">user</span> <span class="o">&lt;-</span> <span class="kt">T</span><span class="o">.</span><span class="n">pack</span> <span class="o">&lt;$&gt;</span> <span class="n">some</span> <span class="n">alphaNumChar</span>
</code></pre>
            </div>
          </div>

          <p>
            我们可以把它替换为
            <code class="language-plaintext highlighter-rouge">takeWhile1P</code
            >：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>  <span class="n">user</span> <span class="o">&lt;-</span> <span class="n">takeWhile1P</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">"alpha num character"</span><span class="p">)</span> <span class="n">isAlphaNum</span>
  <span class="c1">--                  ^                            ^</span>
  <span class="c1">--                  |                            |</span>
  <span class="c1">-- label for tokens we match against         predicate</span>
</code></pre>
            </div>
          </div>

          <p>
            当我们对
            <code class="language-plaintext highlighter-rouge">ByteString</code>
            和
            <code class="language-plaintext highlighter-rouge">Text</code>
            进行语法分析时，这会比原来的方法快很多。顺便注意一下，我们能从
            <code class="language-plaintext highlighter-rouge"
              >takeWhile1P</code
            >
            直接拿到
            <code class="language-plaintext highlighter-rouge">Text</code
            >，所以就不再需要
            <code class="language-plaintext highlighter-rouge">T.pack</code>
            了。
          </p>

          <p>
            下面这些等式对于理解
            <code class="language-plaintext highlighter-rouge">takeWhileP</code>
            和
            <code class="language-plaintext highlighter-rouge"
              >takeWhile1P</code
            >
            的
            <code class="language-plaintext highlighter-rouge"
              >Maybe String</code
            >
            参数很有帮助：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">takeWhileP</span>  <span class="p">(</span><span class="kt">Just</span> <span class="s">"foo"</span><span class="p">)</span> <span class="n">f</span> <span class="o">=</span> <span class="n">many</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">f</span> <span class="o">&lt;?&gt;</span> <span class="s">"foo"</span><span class="p">)</span>
<span class="n">takeWhileP</span>  <span class="kt">Nothing</span>      <span class="n">f</span> <span class="o">=</span> <span class="n">many</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">f</span><span class="p">)</span>
<span class="n">takeWhile1P</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">"foo"</span><span class="p">)</span> <span class="n">f</span> <span class="o">=</span> <span class="n">some</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">f</span> <span class="o">&lt;?&gt;</span> <span class="s">"foo"</span><span class="p">)</span>
<span class="n">takeWhile1P</span> <span class="kt">Nothing</span>      <span class="n">f</span> <span class="o">=</span> <span class="n">some</span> <span class="p">(</span><span class="n">satisfy</span> <span class="n">f</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <h2 id="语法分析错误">语法分析错误</h2>

          <p>
            到现在我们已经探索了
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            的大多数特性，是时候来学习一下语法分析错误了：它们如何定义、如何触发、如何在运行时处理它们。
          </p>

          <h3 id="错误的定义">错误的定义</h3>

          <p>
            <code class="language-plaintext highlighter-rouge">ParseError</code>
            类型有如下定义：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span>
  <span class="o">=</span> <span class="kt">TrivialError</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)))</span> <span class="p">(</span><span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)))</span>
    <span class="c1">-- ^ Trivial errors, generated by Megaparsec's machinery. </span>
    <span class="c1">-- The data constructor includes the offset of error, unexpected token (if any), and expected tokens.</span>
  <span class="o">|</span> <span class="kt">FancyError</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorFancy</span> <span class="n">e</span><span class="p">))</span>
    <span class="c1">-- ^ Fancy, custom errors.</span>
</code></pre>
            </div>
          </div>

          <p>
            用中文来讲：<code class="language-plaintext highlighter-rouge"
              >ParseError</code
            >
            要么是个
            <code class="language-plaintext highlighter-rouge"
              >TrivialError</code
            >
            要么是个
            <code class="language-plaintext highlighter-rouge">FancyError</code
            >，前者会提供偏移量信息、不期而遇的单词（一个或没有）和我们期待的单词集合（可能为空）。
          </p>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >ParseError s e</code
            >
            有下面两个类型参数：
          </p>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">s</code>
              是输入流的类型；
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">e</code>
              是自定义错误的类型。
            </li>
          </ul>

          <p>
            <code class="language-plaintext highlighter-rouge">ErrorItem</code>
            是这样定义的：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">ErrorItem</span> <span class="n">t</span>
  <span class="o">=</span> <span class="kt">Tokens</span> <span class="p">(</span><span class="kt">NonEmpty</span> <span class="n">t</span><span class="p">)</span>      <span class="c1">-- ^ Non-empty stream of tokens</span>
  <span class="o">|</span> <span class="kt">Label</span> <span class="p">(</span><span class="kt">NonEmpty</span> <span class="kt">Char</span><span class="p">)</span>    <span class="c1">-- ^ Label (cannot be empty)</span>
  <span class="o">|</span> <span class="kt">EndOfInput</span>               <span class="c1">-- ^ End of input</span>
</code></pre>
            </div>
          </div>

          <p>
            还有
            <code class="language-plaintext highlighter-rouge">ErrorFancy</code
            >：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">ErrorFancy</span> <span class="n">e</span>
  <span class="o">=</span> <span class="kt">ErrorFail</span> <span class="kt">String</span>
    <span class="c1">-- ^ 'fail' has been used in parser monad</span>
  <span class="o">|</span> <span class="kt">ErrorIndentation</span> <span class="kt">Ordering</span> <span class="kt">Pos</span> <span class="kt">Pos</span>
    <span class="c1">-- ^ Incorrect indentation error:</span>
    <span class="c1">--     desired ordering between reference level and actual level,</span>
    <span class="c1">--     reference indentation level,</span>
    <span class="c1">--     actual indentation level</span>
  <span class="o">|</span> <span class="kt">ErrorCustom</span> <span class="n">e</span>
    <span class="c1">-- ^ Custom error data, can be conveniently disabled by indexing 'ErrorFancy' by 'Void'</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">ErrorFancy</code>
            包括两个
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            常见错误的数据构造器：
          </p>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">fail</code>
              函数会让语法分析器失败并报告任意
              <code class="language-plaintext highlighter-rouge">String</code>；
            </li>
            <li>
              因为该库原生支持对缩进敏感的语法，所以错误类型也能方便地存储缩进相关信息。
            </li>
          </ul>

          <p>
            最后，<code class="language-plaintext highlighter-rouge"
              >ErrorCustom</code
            >
            是允许将任意数据嵌入
            <code class="language-plaintext highlighter-rouge">ErrorFancy</code>
            类型的「扩展槽」。如果我们不需要在语法分析错误中使用自定义数据，我们可以把
            <code class="language-plaintext highlighter-rouge">Void</code> 传给
            <code class="language-plaintext highlighter-rouge">ErrorFancy</code
            >。由于
            <code class="language-plaintext highlighter-rouge">Void</code>
            不接受非底类型的值，<code
              class="language-plaintext highlighter-rouge"
              >ErrorCustom</code
            >
            就相当于「取消」了，用抽象数据类型做类比的话，就是「与零的积」。
          </p>

          <p>
            在旧版本中，<code class="language-plaintext highlighter-rouge"
              >ParseError</code
            >
            会直接被
            <code class="language-plaintext highlighter-rouge">parse</code>
            等函数返回，但版本 7.0
            推迟了每个错误的行和列的计算，以及用于显示错误的相关行内容的获取。这能让语法分析更快，因为这些信息通常只有在语法分析失败时才有用。另一个旧版本的问题是，同时显示多个错误需要每次重新遍历输入来获取正确的行。
          </p>

          <p>
            这个问题现在由
            <code class="language-plaintext highlighter-rouge"
              >ParseErrorBundle</code
            >
            数据类型解决了：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cd">-- | A non-empty collection of 'ParseError's equipped with 'PosState' that</span>
<span class="c1">-- allows to pretty-print the errors efficiently and correctly.</span>

<span class="kr">data</span> <span class="kt">ParseErrorBundle</span> <span class="n">s</span> <span class="n">e</span> <span class="o">=</span> <span class="kt">ParseErrorBundle</span>
  <span class="p">{</span> <span class="n">bundleErrors</span> <span class="o">::</span> <span class="kt">NonEmpty</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span><span class="p">)</span>
    <span class="c1">-- ^ A collection of 'ParseError's that is sorted by parse error offsets</span>
  <span class="p">,</span> <span class="n">bundlePosState</span> <span class="o">::</span> <span class="kt">PosState</span> <span class="n">s</span>
    <span class="c1">-- ^ State that is used for line\/column calculation</span>
  <span class="p">}</span>
</code></pre>
            </div>
          </div>

          <p>
            所有运行语法分析的函数都会返回
            <code class="language-plaintext highlighter-rouge"
              >ParseErrorBundle</code
            >，里面会有设置好的
            <code class="language-plaintext highlighter-rouge"
              >bundlePosState</code
            >
            和
            <code class="language-plaintext highlighter-rouge">ParseError</code
            >。里面的
            <code class="language-plaintext highlighter-rouge">ParseError</code>
            列表可以由用户自行扩展，不过这样得由用户来保证它们仍按照偏移量有序排列。
          </p>

          <h3 id="如何触发错误">如何触发错误</h3>

          <p>
            让我们讨论一下触发语法分析错误的几种不同方式，最简单的是
            <code class="language-plaintext highlighter-rouge">fail</code>
            函数：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (fail "I'm failing, help me!" :: Parser ()) ""
1:1:
  |
1 | &lt;empty line&gt;
  | ^
I'm failing, help me!
</code></pre>
            </div>
          </div>

          <p>
            对于很多熟悉其它简单的语法分析库（比如
            <code class="language-plaintext highlighter-rouge">parsec</code
            >）的人来讲，这通常已经足够了。然而，除了向用户显示语法分析错误之外，我们还有可能需要分析或是处理它，这时候
            <code class="language-plaintext highlighter-rouge">String</code>
            就不是很方便了。
          </p>

          <p>
            平凡的语法分析错误通常都是
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            生成的，但我们也能自己用
            <code class="language-plaintext highlighter-rouge">failure</code>
            组合子触发这样的错误：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">failure</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- ^ Unexpected item (if any)</span>
  <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- ^ Expected items</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">unfortunateParser</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
<span class="n">unfortunateParser</span> <span class="o">=</span> <span class="n">failure</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">EndOfInput</span><span class="p">)</span> <span class="p">(</span><span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">es</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">es</span> <span class="o">=</span> <span class="p">[</span><span class="kt">Tokens</span> <span class="p">(</span><span class="kt">NE</span><span class="o">.</span><span class="n">fromList</span> <span class="s">"a"</span><span class="p">),</span> <span class="kt">Tokens</span> <span class="p">(</span><span class="kt">NE</span><span class="o">.</span><span class="n">fromList</span> <span class="s">"b"</span><span class="p">)]</span>
</code></pre>
            </div>
          </div>
          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>λ&gt; parseTest unfortunateParser ""
1:1:
  |
1 | &lt;empty line&gt;
  | ^
unexpected end of input
expecting 'a' or 'b'
</code></pre>
            </div>
          </div>

          <p>
            跟基于
            <code class="language-plaintext highlighter-rouge">fail</code>
            的方法不同，平凡的错误很容易进行模型匹配，或是审视和修改。
          </p>

          <p>
            对于花哨的错误，相应地我们有
            <code class="language-plaintext highlighter-rouge"
              >fancyFailure</code
            >
            组合子：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">fancyFailure</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorFancy</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- ^ Fancy error components</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            但对于
            <code class="language-plaintext highlighter-rouge"
              >fancyFailure</code
            >，我们通常会去定义一个工具函数，而不是直接调用
            <code class="language-plaintext highlighter-rouge"
              >fancyFailure</code
            >：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">incorrectIndent</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Ordering</span>  <span class="c1">-- ^ Desired ordering between reference level and actual level</span>
  <span class="o">-&gt;</span> <span class="kt">Pos</span>               <span class="c1">-- ^ Reference indentation level</span>
  <span class="o">-&gt;</span> <span class="kt">Pos</span>               <span class="c1">-- ^ Actual indentation level</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">incorrectIndent</span> <span class="n">ord</span> <span class="n">ref</span> <span class="n">actual</span> <span class="o">=</span> <span class="n">fancyFailure</span> <span class="o">.</span> <span class="kt">E</span><span class="o">.</span><span class="n">singleton</span> <span class="o">$</span>
  <span class="kt">ErrorIndentation</span> <span class="n">ord</span> <span class="n">ref</span> <span class="n">actual</span>
</code></pre>
            </div>
          </div>

          <p>
            作为添加自定义语法分析错误组件的例子，让我们创建这样一个特殊的语法分析错误，它会报告给定的
            <code class="language-plaintext highlighter-rouge">Text</code>
            值不是关键字。
          </p>

          <p>
            首先，我们需要定义一个数据类型，其构造器代表我们想要支持的场景：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">Custom</span> <span class="o">=</span> <span class="kt">NotKeyword</span> <span class="kt">Text</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            并告诉
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            如何显示这个错误：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">instance</span> <span class="kt">ShowErrorComponent</span> <span class="kt">Custom</span> <span class="kr">where</span>
  <span class="n">showErrorComponent</span> <span class="p">(</span><span class="kt">NotKeyword</span> <span class="n">txt</span><span class="p">)</span> <span class="o">=</span> <span class="kt">T</span><span class="o">.</span><span class="n">unpack</span> <span class="n">txt</span> <span class="o">++</span> <span class="s">" is not a keyword"</span>
</code></pre>
            </div>
          </div>

          <p>
            接下来我们更新一下我们的
            <code class="language-plaintext highlighter-rouge">Parser</code>
            别名：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Custom</span> <span class="kt">Text</span>
</code></pre>
            </div>
          </div>

          <p>
            之后我们定义一个
            <code class="language-plaintext highlighter-rouge">notKeyword</code>
            工具函数：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">notKeyword</span> <span class="o">::</span> <span class="kt">Text</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="n">notKeyword</span> <span class="o">=</span> <span class="n">customFailure</span> <span class="o">.</span> <span class="kt">NotKeyword</span>
</code></pre>
            </div>
          </div>

          <p>
            其中
            <code class="language-plaintext highlighter-rouge"
              >customFailure</code
            >
            是来自
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec</code
            >
            模块的工具函数：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">customFailure</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">customFailure</span> <span class="o">=</span> <span class="n">fancyFailure</span> <span class="o">.</span> <span class="kt">E</span><span class="o">.</span><span class="n">singleton</span> <span class="o">.</span> <span class="kt">ErrorCustom</span>
</code></pre>
            </div>
          </div>

          <p>最后，让我们试一下：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (notKeyword "foo" :: Parser ()) ""
1:1:
  |
1 | &lt;empty line&gt;
  | ^
foo is not a keyword
</code></pre>
            </div>
          </div>

          <h3 id="显示错误">显示错误</h3>

          <p>
            显示
            <code class="language-plaintext highlighter-rouge"
              >ParseErrorBundle</code
            >
            可以用
            <code class="language-plaintext highlighter-rouge"
              >errorBundlePretty</code
            >
            函数完成：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cd">-- | Pretty-print a 'ParseErrorBundle'. All 'ParseError's in the bundle will</span>
<span class="c1">-- be pretty-printed in order together with the corresponding offending</span>
<span class="c1">-- lines by doing a single efficient pass over the input stream. The</span>
<span class="c1">-- rendered 'String' always ends with a newline.</span>

<span class="n">errorBundlePretty</span>
  <span class="o">::</span> <span class="p">(</span> <span class="kt">Stream</span> <span class="n">s</span>
     <span class="p">,</span> <span class="kt">ShowErrorComponent</span> <span class="n">e</span>
     <span class="p">)</span>
  <span class="o">=&gt;</span> <span class="kt">ParseErrorBundle</span> <span class="n">s</span> <span class="n">e</span> <span class="c1">-- ^ Parse error bundle to display</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>               <span class="c1">-- ^ Textual rendition of the bundle</span>
</code></pre>
            </div>
          </div>

          <p>99% 的情况下你只需要这么一个函数。</p>

          <h3 id="在运行时接住错误">在运行时接住错误</h3>

          <p>
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            另一个有用的特性是它能够「接住」语法分析错误，并以某种方式改变它，然后再重新抛出错误，就像异常一样。这可以用
            <code class="language-plaintext highlighter-rouge">observing</code>
            原语实现：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cd">-- | @'observing' p@ allows to “observe” failure of the @p@ parser, should</span>
<span class="c1">-- it happen, without actually ending parsing, but instead getting the</span>
<span class="c1">-- 'ParseError' in 'Left'. On success parsed value is returned in 'Right'</span>
<span class="c1">-- as usual. Note that this primitive just allows you to observe parse</span>
<span class="c1">-- errors as they happen, it does not backtrack or change how the @p@</span>
<span class="c1">-- parser works in any way.</span>

<span class="n">observing</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="n">m</span> <span class="n">a</span>             <span class="c1">-- ^ The parser to run</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            下面是演示
            <code class="language-plaintext highlighter-rouge">observing</code>
            典型用法的完整程序：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="cp">{-# LANGUAGE TypeApplications  #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">intercalate</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Set</span> <span class="p">(</span><span class="kt">Set</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec.Char</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">Set</span>

<span class="kr">data</span> <span class="kt">Custom</span>
  <span class="o">=</span> <span class="kt">TrivialWithLocation</span>
    <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="c1">-- position stack</span>
    <span class="p">(</span><span class="kt">Maybe</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="kt">Char</span><span class="p">))</span>
    <span class="p">(</span><span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="kt">Char</span><span class="p">))</span>
  <span class="o">|</span> <span class="kt">FancyWithLocation</span>
    <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="c1">-- position stack</span>
    <span class="p">(</span><span class="kt">ErrorFancy</span> <span class="kt">Void</span><span class="p">)</span> <span class="c1">-- Void, because we do not want to allow to nest Customs</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">ShowErrorComponent</span> <span class="kt">Custom</span> <span class="kr">where</span>
  <span class="n">showErrorComponent</span> <span class="p">(</span><span class="kt">TrivialWithLocation</span> <span class="n">stack</span> <span class="n">us</span> <span class="n">es</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">parseErrorTextPretty</span> <span class="p">(</span><span class="kt">TrivialError</span> <span class="o">@</span><span class="kt">Char</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">undefined</span> <span class="n">us</span> <span class="n">es</span><span class="p">)</span>
      <span class="o">++</span> <span class="n">showPosStack</span> <span class="n">stack</span>
  <span class="n">showErrorComponent</span> <span class="p">(</span><span class="kt">FancyWithLocation</span> <span class="n">stack</span> <span class="n">cs</span><span class="p">)</span> <span class="o">=</span>
    <span class="n">parseErrorTextPretty</span> <span class="p">(</span><span class="kt">FancyError</span> <span class="o">@</span><span class="kt">Text</span> <span class="o">@</span><span class="kt">Void</span> <span class="n">undefined</span> <span class="p">(</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="n">cs</span><span class="p">))</span>
      <span class="o">++</span> <span class="n">showPosStack</span> <span class="n">stack</span>

<span class="n">showPosStack</span> <span class="o">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">showPosStack</span> <span class="o">=</span> <span class="n">intercalate</span> <span class="s">", "</span> <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="s">"in "</span> <span class="o">++</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Custom</span> <span class="kt">Text</span>

<span class="n">inside</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>
<span class="n">inside</span> <span class="n">location</span> <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">observing</span> <span class="n">p</span>
  <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="p">(</span><span class="kt">TrivialError</span> <span class="kr">_</span> <span class="n">us</span> <span class="n">es</span><span class="p">)</span> <span class="o">-&gt;</span>
      <span class="n">fancyFailure</span> <span class="o">.</span> <span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="o">.</span> <span class="kt">ErrorCustom</span> <span class="o">$</span>
        <span class="kt">TrivialWithLocation</span> <span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="n">us</span> <span class="n">es</span>
    <span class="kt">Left</span> <span class="p">(</span><span class="kt">FancyError</span> <span class="kr">_</span> <span class="n">xs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kr">do</span>
      <span class="kr">let</span> <span class="n">f</span> <span class="p">(</span><span class="kt">ErrorFail</span> <span class="n">msg</span><span class="p">)</span> <span class="o">=</span> <span class="kt">ErrorCustom</span> <span class="o">$</span>
            <span class="kt">FancyWithLocation</span> <span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="p">(</span><span class="kt">ErrorFail</span> <span class="n">msg</span><span class="p">)</span>
          <span class="n">f</span> <span class="p">(</span><span class="kt">ErrorIndentation</span> <span class="n">ord</span> <span class="n">rlvl</span> <span class="n">alvl</span><span class="p">)</span> <span class="o">=</span> <span class="kt">ErrorCustom</span> <span class="o">$</span>
            <span class="kt">FancyWithLocation</span> <span class="p">[</span><span class="n">location</span><span class="p">]</span> <span class="p">(</span><span class="kt">ErrorIndentation</span> <span class="n">ord</span> <span class="n">rlvl</span> <span class="n">alvl</span><span class="p">)</span>
          <span class="n">f</span> <span class="p">(</span><span class="kt">ErrorCustom</span> <span class="p">(</span><span class="kt">TrivialWithLocation</span> <span class="n">ps</span> <span class="n">us</span> <span class="n">es</span><span class="p">))</span> <span class="o">=</span> <span class="kt">ErrorCustom</span> <span class="o">$</span>
            <span class="kt">TrivialWithLocation</span> <span class="p">(</span><span class="n">location</span><span class="o">:</span><span class="n">ps</span><span class="p">)</span> <span class="n">us</span> <span class="n">es</span>
          <span class="n">f</span> <span class="p">(</span><span class="kt">ErrorCustom</span> <span class="p">(</span><span class="kt">FancyWithLocation</span> <span class="n">ps</span> <span class="n">cs</span><span class="p">))</span> <span class="o">=</span> <span class="kt">ErrorCustom</span> <span class="o">$</span>
            <span class="kt">FancyWithLocation</span> <span class="p">(</span><span class="n">location</span><span class="o">:</span><span class="n">ps</span><span class="p">)</span> <span class="n">cs</span>
      <span class="n">fancyFailure</span> <span class="p">(</span><span class="kt">Set</span><span class="o">.</span><span class="n">map</span> <span class="n">f</span> <span class="n">xs</span><span class="p">)</span>
    <span class="kt">Right</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="n">x</span>

<span class="n">myParser</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">myParser</span> <span class="o">=</span> <span class="n">some</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'a'</span><span class="p">)</span> <span class="o">*&gt;</span> <span class="n">some</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'b'</span><span class="p">)</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">parseTest</span> <span class="p">(</span><span class="n">inside</span> <span class="s">"foo"</span> <span class="n">myParser</span><span class="p">)</span> <span class="s">"aaacc"</span>
  <span class="n">parseTest</span> <span class="p">(</span><span class="n">inside</span> <span class="s">"foo"</span> <span class="o">$</span> <span class="n">inside</span> <span class="s">"bar"</span> <span class="n">myParser</span><span class="p">)</span> <span class="s">"aaacc"</span>
</code></pre>
            </div>
          </div>

          <p>【练习】深入理解这个程序是如何工作的。</p>

          <p>如果运行这个程序，会看到以下输出：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code>1:4:
  |
1 | aaacc
  |    ^
unexpected 'c'
expecting 'a' or 'b'
in foo
1:4:
  |
1 | aaacc
  |    ^
unexpected 'c'
expecting 'a' or 'b'
in foo, in bar
</code></pre>
            </div>
          </div>

          <p>
            因此，这个特性可以用来给语法分析错误附加位置标签，或是定义能以某种方式处理该错误的「区域」。这种惯用法很有用，所以甚至有一个基于
            <code class="language-plaintext highlighter-rouge">observing</code>
            定义的工具函数
            <code class="language-plaintext highlighter-rouge">region</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cd">-- | Specify how to process 'ParseError's that happen inside of this</span>
<span class="c1">-- wrapper. This applies to both normal and delayed 'ParseError's.</span>
<span class="c1">--</span>
<span class="c1">-- As a side-effect of the implementation the inner computation will start</span>
<span class="c1">-- with empty collection of delayed errors and they will be updated and</span>
<span class="c1">-- “restored” on the way out of 'region'.</span>

<span class="n">region</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- ^ How to process 'ParseError's</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>                 <span class="c1">-- ^ The “region” that the processing applies to</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">region</span> <span class="n">f</span> <span class="n">m</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">observing</span> <span class="n">m</span>
  <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="n">err</span> <span class="o">-&gt;</span> <span class="n">parseError</span> <span class="p">(</span><span class="n">f</span> <span class="n">err</span><span class="p">)</span> <span class="c1">-- see the next section</span>
    <span class="kt">Right</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="n">x</span>
</code></pre>
            </div>
          </div>

          <p>
            【练习】用
            <code class="language-plaintext highlighter-rouge">region</code>
            重写之前程序中的
            <code class="language-plaintext highlighter-rouge">inside</code>
            函数。
          </p>

          <h3 id="控制错误的位置">控制错误的位置</h3>

          <p>
            <code class="language-plaintext highlighter-rouge">region</code>
            的定义使用了
            <code class="language-plaintext highlighter-rouge">parseError</code>
            原语：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">parseError</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</code></pre>
            </div>
          </div>

          <p>
            这是错误报告的基础原语，我们目前见到的所有其它函数都基于
            <code class="language-plaintext highlighter-rouge">parseError</code>
            定义的：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">failure</span>
  <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- ^ Unexpected item (if any)</span>
  <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- ^ Expected items</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">failure</span> <span class="n">us</span> <span class="n">ps</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">o</span> <span class="o">&lt;-</span> <span class="n">getOffset</span>
  <span class="n">parseError</span> <span class="p">(</span><span class="kt">TrivialError</span> <span class="n">o</span> <span class="n">us</span> <span class="n">ps</span><span class="p">)</span>
</code></pre>
            </div>
          </div>
          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">fancyFailure</span>
  <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorFancy</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- ^ Fancy error components</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
<span class="n">fancyFailure</span> <span class="n">xs</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">o</span> <span class="o">&lt;-</span> <span class="n">getOffset</span>
  <span class="n">parseError</span> <span class="p">(</span><span class="kt">FancyError</span> <span class="n">o</span> <span class="n">xs</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">parseError</code>
            可以让你设置错误的偏移量（也就是位置），而不必是输入流的当前位置。让我们回到很久之前的那个例子：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">withPredicate2</span>
  <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>       <span class="c1">-- ^ The check to perform on parsed input</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>            <span class="c1">-- ^ Message to print when the check fails</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Resulting parser that performs the check</span>
<span class="n">withPredicate2</span> <span class="n">f</span> <span class="n">msg</span> <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">o</span> <span class="o">&lt;-</span> <span class="n">getOffset</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">p</span>
  <span class="kr">if</span> <span class="n">f</span> <span class="n">r</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">r</span>
    <span class="kr">else</span> <span class="kr">do</span>
      <span class="n">setOffset</span> <span class="n">o</span>
      <span class="n">fail</span> <span class="n">msg</span>
</code></pre>
            </div>
          </div>

          <p>
            我们注意到
            <code class="language-plaintext highlighter-rouge"
              >setOffset o</code
            >
            能让错误被正确定位，但它的副作用是会使语法分析状态失效，也就是说偏移量不再反映现实情况了。在更复杂的语法分析器中，这可能会是个现实的问题。举例来说，想象一下你用
            <code class="language-plaintext highlighter-rouge">observing</code>
            包住了
            <code class="language-plaintext highlighter-rouge"
              >withPredicate2</code
            >，那么
            <code class="language-plaintext highlighter-rouge">fail</code>
            之后可能还会有代码运行。
          </p>

          <p>
            有了
            <code class="language-plaintext highlighter-rouge">parseError</code>
            和
            <code class="language-plaintext highlighter-rouge">region</code
            >，我们能够正确地解决这个问题了：要么使用
            <code class="language-plaintext highlighter-rouge">parseError</code>
            来重设错误位置，要么直接用
            <code class="language-plaintext highlighter-rouge">region</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">withPredicate3</span>
  <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>       <span class="c1">-- ^ The check to perform on parsed input</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>            <span class="c1">-- ^ Message to print when the check fails</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Resulting parser that performs the check</span>
<span class="n">withPredicate3</span> <span class="n">f</span> <span class="n">msg</span> <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">o</span> <span class="o">&lt;-</span> <span class="n">getOffset</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">p</span>
  <span class="kr">if</span> <span class="n">f</span> <span class="n">r</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">r</span>
    <span class="kr">else</span> <span class="n">region</span> <span class="p">(</span><span class="n">setErrorOffset</span> <span class="n">o</span><span class="p">)</span> <span class="p">(</span><span class="n">fail</span> <span class="n">msg</span><span class="p">)</span>
</code></pre>
            </div>
          </div>
          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">withPredicate4</span>
  <span class="o">::</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span>       <span class="c1">-- ^ The check to perform on parsed input</span>
  <span class="o">-&gt;</span> <span class="kt">String</span>            <span class="c1">-- ^ Message to print when the check fails</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="n">a</span>          <span class="c1">-- ^ Resulting parser that performs the check</span>
<span class="n">withPredicate4</span> <span class="n">f</span> <span class="n">msg</span> <span class="n">p</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">o</span> <span class="o">&lt;-</span> <span class="n">getOffset</span>
  <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">p</span>
  <span class="kr">if</span> <span class="n">f</span> <span class="n">r</span>
    <span class="kr">then</span> <span class="n">return</span> <span class="n">r</span>
    <span class="kr">else</span> <span class="n">parseError</span> <span class="p">(</span><span class="kt">FancyError</span> <span class="n">o</span> <span class="p">(</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="kt">ErrorFail</span> <span class="n">msg</span><span class="p">)))</span>
</code></pre>
            </div>
          </div>

          <h3 id="报告多个错误">报告多个错误</h3>

          <p>
            最后，<code class="language-plaintext highlighter-rouge"
              >megaparsec</code
            >
            允许我们在一次运行过程中触发多个语法分析错误。这能帮助我们一次修复多处错误，而不需要运行好几次语法分析器。
          </p>

          <p>
            拥有多错误语法分析器的前提条件是，它要能跳过一部分有问题的输入，并从一个已知没问题的位置继续进行语法分析。这部分工作要用
            <code class="language-plaintext highlighter-rouge"
              >withRecovery</code
            >
            原语完成：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cd">-- | @'withRecovery' r p@ allows continue parsing even if parser @p@</span>
<span class="c1">-- fails. In this case @r@ is called with the actual 'ParseError' as its</span>
<span class="c1">-- argument. Typical usage is to return a value signifying failure to</span>
<span class="c1">-- parse this particular object and to consume some part of the input up</span>
<span class="c1">-- to the point where the next object starts.</span>
<span class="c1">--</span>
<span class="c1">-- Note that if @r@ fails, original error message is reported as if</span>
<span class="c1">-- without 'withRecovery'. In no way recovering parser @r@ can influence</span>
<span class="c1">-- error messages.</span>

<span class="n">withRecovery</span>
  <span class="o">::</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span><span class="p">)</span> <span class="c1">-- ^ How to recover from failure</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>             <span class="c1">-- ^ Original parser</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>             <span class="c1">-- ^ Parser that can recover from failures</span>
</code></pre>
            </div>
          </div>

          <p>
            在 Megaparsec 8 之前，<code
              class="language-plaintext highlighter-rouge"
              >a</code
            >
            必须是包含成功和失败两种可能性的和类型，比如说
            <code class="language-plaintext highlighter-rouge"
              >Either (ParseError s e) Result</code
            >。语法分析错误在收集后会加入
            <code class="language-plaintext highlighter-rouge"
              >ParseErrorBundle</code
            >
            以进行显示。不必说，这些都是对用户不友好的高级用法。
          </p>

          <p>Megaparsec 8 支持了「延迟错误」：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cd">-- | Register a 'ParseError' for later reporting. This action does not end</span>
<span class="c1">-- parsing and has no effect except for adding the given 'ParseError' to the</span>
<span class="c1">-- collection of “delayed” 'ParseError's which will be taken into</span>
<span class="c1">-- consideration at the end of parsing. Only if this collection is empty</span>
<span class="c1">-- parser will succeed. This is the main way to report several parse errors</span>
<span class="c1">-- at once.</span>

<span class="n">registerParseError</span> <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">ParseError</span> <span class="n">s</span> <span class="n">e</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>

<span class="cd">-- | Like 'failure', but for delayed 'ParseError's.</span>

<span class="n">registerFailure</span>
  <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- ^ Unexpected item (if any)</span>
  <span class="o">-&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorItem</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">))</span> <span class="c1">-- ^ Expected items</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>

<span class="cd">-- | Like 'fancyFailure', but for delayed 'ParseError's.</span>

<span class="n">registerFancyFailure</span>
  <span class="o">::</span> <span class="kt">MonadParsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">Set</span> <span class="p">(</span><span class="kt">ErrorFancy</span> <span class="n">e</span><span class="p">)</span> <span class="c1">-- ^ Fancy error components</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
</code></pre>
            </div>
          </div>

          <p>
            这些错误可以在
            <code class="language-plaintext highlighter-rouge"
              >withRecovery</code
            >
            的错误处理回调中注册，所以结果类型会是
            <code class="language-plaintext highlighter-rouge"
              >Maybe Result</code
            >。这样可以把延迟错误列入最后的
            <code class="language-plaintext highlighter-rouge"
              >ParseErrorBundle</code
            >，并且在错误列表非空的情况让语法分析失败。
          </p>

          <p>
            有了这些，我们希望编写多错误语法分析器的做法会在用户群中更加普遍。
          </p>

          <h2 id="测试-megaparsec-语法分析器">测试 Megaparsec 语法分析器</h2>

          <p>
            对语法分析器进行测试是大多数人迟早要面对的事情，所以我们有义务提一下。最推荐的方式是使用
            <a href="https://hackage.haskell.org/package/hspec-megaparsec"
              >hspec-megaparsec</a
            >
            包，里面有一些效用期望，比如
            <code class="language-plaintext highlighter-rouge">shouldParse</code
            >、<code class="language-plaintext highlighter-rouge"
              >parseSatisfies</code
            >
            等等，能和
            <code class="language-plaintext highlighter-rouge">hspec</code>
            测试框架协同工作。
          </p>

          <p>让我们从一个用例开始：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Applicative</span>
<span class="kr">import</span> <span class="nn">Data.Text</span> <span class="p">(</span><span class="kt">Text</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Test.Hspec</span>
<span class="kr">import</span> <span class="nn">Test.Hspec.Megaparsec</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec.Char</span>

<span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">Text</span>

<span class="n">myParser</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">String</span>
<span class="n">myParser</span> <span class="o">=</span> <span class="n">some</span> <span class="p">(</span><span class="n">char</span> <span class="sc">'a'</span><span class="p">)</span>

<span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">hspec</span> <span class="o">$</span>
  <span class="n">describe</span> <span class="s">"myParser"</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">it</span> <span class="s">"returns correct result"</span> <span class="o">$</span>
      <span class="n">parse</span> <span class="n">myParser</span> <span class="s">""</span> <span class="s">"aaa"</span> <span class="p">`</span><span class="n">shouldParse</span><span class="p">`</span> <span class="s">"aaa"</span>
    <span class="n">it</span> <span class="s">"result of parsing satisfies what it should"</span> <span class="o">$</span>
      <span class="n">parse</span> <span class="n">myParser</span> <span class="s">""</span> <span class="s">"aaaa"</span> <span class="p">`</span><span class="n">parseSatisfies</span><span class="p">`</span> <span class="p">((</span><span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="o">.</span> <span class="n">length</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >shouldParse</code
            >
            接受
            <code class="language-plaintext highlighter-rouge"
              >Either (ParseErrorBundle s e) a</code
            >，即语法分析的结果和一个用来进行比较的
            <code class="language-plaintext highlighter-rouge">a</code>
            类型的值，这可能是用得最多的工具函数。<code
              class="language-plaintext highlighter-rouge"
              >parseSatisfies</code
            >
            跟它很相似，但不是跟期待的结果比较是否相等，而是用任意断言检查结果。
          </p>

          <p>
            其它简单的效用期望还有
            <code class="language-plaintext highlighter-rouge"
              >shouldSucceedOn</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >shouldFailOn</code
            >（但很少用到它们）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>    <span class="n">it</span> <span class="s">"should parse 'a's all right"</span> <span class="o">$</span>
      <span class="n">parse</span> <span class="n">myParser</span> <span class="s">""</span> <span class="p">`</span><span class="n">shouldSucceedOn</span><span class="p">`</span> <span class="s">"aaaa"</span>
    <span class="n">it</span> <span class="s">"should fail on 'b's"</span> <span class="o">$</span>
      <span class="n">parse</span> <span class="n">myParser</span> <span class="s">""</span> <span class="p">`</span><span class="n">shouldFailOn</span><span class="p">`</span> <span class="s">"bbb"</span>
</code></pre>
            </div>
          </div>

          <p>
            在使用
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            时，我们想要让语法分析错误更加精确。为了测试语法分析错误我们可以使用
            <code class="language-plaintext highlighter-rouge"
              >shouldFailWith</code
            >，用法如下：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>    <span class="n">it</span> <span class="s">"fails on 'b's producing correct error message"</span> <span class="o">$</span>
      <span class="n">parse</span> <span class="n">myParser</span> <span class="s">""</span> <span class="s">"bbb"</span> <span class="p">`</span><span class="n">shouldFailWith</span><span class="p">`</span>
        <span class="kt">TrivialError</span>
          <span class="mi">0</span>
          <span class="p">(</span><span class="kt">Just</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="p">(</span><span class="sc">'b'</span> <span class="o">:|</span> <span class="kt">[]</span><span class="p">)))</span>
          <span class="p">(</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="p">(</span><span class="kt">Tokens</span> <span class="p">(</span><span class="sc">'a'</span> <span class="o">:|</span> <span class="kt">[]</span><span class="p">)))</span>
</code></pre>
            </div>
          </div>

          <p>
            像这样写出
            <code class="language-plaintext highlighter-rouge"
              >TrivialError</code
            >
            挺让人厌烦的。<code class="language-plaintext highlighter-rouge"
              >ParseError</code
            >
            的定义包含了像
            <code class="language-plaintext highlighter-rouge">Set</code> 和
            <code class="language-plaintext highlighter-rouge">NonEmpty</code>
            这样「不方便」的类型，就像我们上面见到的那样，写起来很麻烦。幸运的是，<code
              class="language-plaintext highlighter-rouge"
              >Test.Hspec.Megaparsec</code
            >
            也重新导出了
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Error.Builder</code
            >
            模块，里面提供了更方便地构建
            <code class="language-plaintext highlighter-rouge">ParseError</code>
            的 API。让我们来看看
            <code class="language-plaintext highlighter-rouge">err</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>    <span class="n">it</span> <span class="s">"fails on 'b's producing correct error message"</span> <span class="o">$</span>
      <span class="n">parse</span> <span class="n">myParser</span> <span class="s">""</span> <span class="s">"bbb"</span> <span class="p">`</span><span class="n">shouldFailWith</span><span class="p">`</span> <span class="n">err</span> <span class="mi">0</span> <span class="p">(</span><span class="n">utok</span> <span class="sc">'b'</span> <span class="o">&lt;&gt;</span> <span class="n">etok</span> <span class="sc">'a'</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">err</code>
              的第一个参数是错误的偏移量（在出错之前我们吃掉了多少单词），这里它就是
              0。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">utok</code>
              表示「不期而遇的单词」，类似地
              <code class="language-plaintext highlighter-rouge">etok</code>
              表示「我们期待的单词」。
            </li>
          </ul>

          <p>
            【练习】要构建花哨的错误，也有类似的工具函数叫做
            <code class="language-plaintext highlighter-rouge">errFancy</code
            >，请了解一下。
          </p>

          <p>
            最后，还可以用
            <code class="language-plaintext highlighter-rouge"
              >failsLeaving</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >succeedLeaving</code
            >
            来测试输入的哪部分在语法分析后还没被吃掉：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>    <span class="n">it</span> <span class="s">"consumes all 'a's but does not touch 'b's"</span> <span class="o">$</span>
      <span class="n">runParser'</span> <span class="n">myParser</span> <span class="p">(</span><span class="n">initialState</span> <span class="s">"aaabbb"</span><span class="p">)</span> <span class="p">`</span><span class="n">succeedsLeaving</span><span class="p">`</span> <span class="s">"bbb"</span>
    <span class="n">it</span> <span class="s">"fails without consuming anything"</span> <span class="o">$</span>
      <span class="n">runParser'</span> <span class="n">myParser</span> <span class="p">(</span><span class="n">initialState</span> <span class="s">"bbbccc"</span><span class="p">)</span> <span class="p">`</span><span class="n">failsLeaving</span><span class="p">`</span> <span class="s">"bbbccc"</span>
</code></pre>
            </div>
          </div>

          <p>
            这些函数应该用
            <code class="language-plaintext highlighter-rouge">runParser'</code>
            和
            <code class="language-plaintext highlighter-rouge"
              >runParserT'</code
            >
            运行，因为它们支持自定义初始状态并且会返回最终状态（这就能检查输入流剩下的东西了）：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="n">runParser'</span>
  <span class="o">::</span> <span class="kt">Parsec</span> <span class="n">e</span> <span class="n">s</span> <span class="n">a</span>      <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">State</span> <span class="n">s</span>           <span class="c1">-- ^ Initial state</span>
  <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</code></pre>
            </div>
          </div>
          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">runParserT'</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span>
  <span class="o">=&gt;</span> <span class="kt">ParsecT</span> <span class="n">e</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span>   <span class="c1">-- ^ Parser to run</span>
  <span class="o">-&gt;</span> <span class="kt">State</span> <span class="n">s</span>           <span class="c1">-- ^ Initial state</span>
  <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="kt">State</span> <span class="n">s</span><span class="p">,</span> <span class="kt">Either</span> <span class="p">(</span><span class="kt">ParseError</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">s</span><span class="p">)</span> <span class="n">e</span><span class="p">)</span> <span class="n">a</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge"
              >initialState</code
            >
            函数接受输入流，返回该输入流构成的初始状态，而初始状态的其它记录字段会用默认值填充。
          </p>

          <p>
            关于使用
            <code class="language-plaintext highlighter-rouge"
              >hspec-megaparsec</code
            >，下述代码会是你的灵感来源：
          </p>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge"
                >hspec-megaparsec</code
              >
              编写的
              <a
                href="https://github.com/mrkkrp/megaparsec/tree/master/megaparsec-tests/tests"
                >Megaparsec 自己的测试套件</a
              >；
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge"
                >hspec-megaparsec</code
              >
              自带的<a
                href="https://github.com/mrkkrp/hspec-megaparsec/blob/master/tests/Main.hs"
                >玩具测试套件</a
              >。
            </li>
          </ul>

          <h2 id="使用自定义输入流">使用自定义输入流</h2>

          <p>
            <code class="language-plaintext highlighter-rouge">megaparsec</code>
            能用来对任何输入流进行语法分析，只要它是
            <code class="language-plaintext highlighter-rouge">Stream</code>
            类型类的实例。这意味着它可以和
            <code class="language-plaintext highlighter-rouge">alex</code>
            之类的词法分析工具配合使用。
          </p>

          <p>
            为了不偏离我们的主题，我们不会展示
            <code class="language-plaintext highlighter-rouge">alex</code>
            是如何生成单词流的，我们就假定输入是下述形式：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">{-# LANGUAGE LambdaCase        #-}</span>
<span class="cp">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="cp">{-# LANGUAGE RecordWildCards   #-}</span>
<span class="cp">{-# LANGUAGE TypeFamilies      #-}</span>

<span class="kr">module</span> <span class="nn">Main</span> <span class="p">(</span><span class="nf">main</span><span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.List.NonEmpty</span> <span class="p">(</span><span class="kt">NonEmpty</span> <span class="p">(</span><span class="o">..</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Data.Proxy</span>
<span class="kr">import</span> <span class="nn">Data.Void</span>
<span class="kr">import</span> <span class="nn">Text.Megaparsec</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.List</span>          <span class="k">as</span> <span class="n">DL</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.List.NonEmpty</span> <span class="k">as</span> <span class="n">NE</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span>           <span class="k">as</span> <span class="n">Set</span>

<span class="kr">data</span> <span class="kt">MyToken</span>
  <span class="o">=</span> <span class="kt">Int</span> <span class="kt">Int</span>
  <span class="o">|</span> <span class="kt">Plus</span>
  <span class="o">|</span> <span class="kt">Mul</span>
  <span class="o">|</span> <span class="kt">Div</span>
  <span class="o">|</span> <span class="kt">OpenParen</span>
  <span class="o">|</span> <span class="kt">CloseParen</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>
            为了报告语法分析错误，我们需要一种方式知道单词的起始位置、终止位置和长度，因此我们添加了
            <code class="language-plaintext highlighter-rouge">WithPos</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">WithPos</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">WithPos</span>
  <span class="p">{</span> <span class="n">startPos</span> <span class="o">::</span> <span class="kt">SourcePos</span>
  <span class="p">,</span> <span class="n">endPos</span> <span class="o">::</span> <span class="kt">SourcePos</span>
  <span class="p">,</span> <span class="n">tokenLength</span> <span class="o">::</span> <span class="kt">Int</span>
  <span class="p">,</span> <span class="n">tokenVal</span> <span class="o">::</span> <span class="n">a</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>这下我们就有数据类型表示自己的流了：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">data</span> <span class="kt">MyStream</span> <span class="o">=</span> <span class="kt">MyStream</span>
  <span class="p">{</span> <span class="n">myStreamInput</span> <span class="o">::</span> <span class="kt">String</span> <span class="c1">-- for showing offending lines</span>
  <span class="p">,</span> <span class="n">unMyStream</span> <span class="o">::</span> <span class="p">[</span><span class="kt">WithPos</span> <span class="kt">MyToken</span><span class="p">]</span>
  <span class="p">}</span>
</code></pre>
            </div>
          </div>

          <p>
            接下来，我们需要让
            <code class="language-plaintext highlighter-rouge">MyStream</code>
            成为
            <code class="language-plaintext highlighter-rouge">Stream</code>
            类型类的实例。这需要
            <code class="language-plaintext highlighter-rouge"
              >TypeFamilies</code
            >
            语言扩展，因为我们想要定义关联类型函数
            <code class="language-plaintext highlighter-rouge">Token</code> 和
            <code class="language-plaintext highlighter-rouge">Tokens</code>：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">instance</span> <span class="kt">Stream</span> <span class="kt">MyStream</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Token</span>  <span class="kt">MyStream</span> <span class="o">=</span> <span class="kt">WithPos</span> <span class="kt">MyToken</span>
  <span class="kr">type</span> <span class="kt">Tokens</span> <span class="kt">MyStream</span> <span class="o">=</span> <span class="p">[</span><span class="kt">WithPos</span> <span class="kt">MyToken</span><span class="p">]</span>
  <span class="c1">-- …</span>
</code></pre>
            </div>
          </div>

          <p>
            <code class="language-plaintext highlighter-rouge">Stream</code>
            的文档可以在
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Stream</code
            >
            模块中找到。现在我们直接把剩下的方法定义完：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre class="highlight"><code><span class="c1">-- …</span>
  <span class="n">tokenToChunk</span> <span class="kt">Proxy</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
  <span class="n">tokensToChunk</span> <span class="kt">Proxy</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="n">chunkToTokens</span> <span class="kt">Proxy</span> <span class="o">=</span> <span class="n">id</span>
  <span class="n">chunkLength</span> <span class="kt">Proxy</span> <span class="o">=</span> <span class="n">length</span>
  <span class="n">chunkEmpty</span> <span class="kt">Proxy</span> <span class="o">=</span> <span class="n">null</span>
  <span class="n">take1_</span> <span class="p">(</span><span class="kt">MyStream</span> <span class="kr">_</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">=</span> <span class="kt">Nothing</span>
  <span class="n">take1_</span> <span class="p">(</span><span class="kt">MyStream</span> <span class="n">str</span> <span class="p">(</span><span class="n">t</span><span class="o">:</span><span class="n">ts</span><span class="p">))</span> <span class="o">=</span> <span class="kt">Just</span>
    <span class="p">(</span> <span class="n">t</span>
    <span class="p">,</span> <span class="kt">MyStream</span> <span class="p">(</span><span class="n">drop</span> <span class="p">(</span><span class="n">tokensLength</span> <span class="n">pxy</span> <span class="p">(</span><span class="n">t</span><span class="o">:|</span><span class="kt">[]</span><span class="p">))</span> <span class="n">str</span><span class="p">)</span> <span class="n">ts</span>
    <span class="p">)</span>
  <span class="n">takeN_</span> <span class="n">n</span> <span class="p">(</span><span class="kt">MyStream</span> <span class="n">str</span> <span class="n">s</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>    <span class="o">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kt">MyStream</span> <span class="n">str</span> <span class="n">s</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">null</span> <span class="n">s</span>    <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span>
        <span class="kr">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s'</span><span class="p">)</span> <span class="o">=</span> <span class="n">splitAt</span> <span class="n">n</span> <span class="n">s</span>
        <span class="kr">in</span> <span class="kr">case</span> <span class="kt">NE</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="n">x</span> <span class="kr">of</span>
          <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">MyStream</span> <span class="n">str</span> <span class="n">s'</span><span class="p">)</span>
          <span class="kt">Just</span> <span class="n">nex</span> <span class="o">-&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">MyStream</span> <span class="p">(</span><span class="n">drop</span> <span class="p">(</span><span class="n">tokensLength</span> <span class="n">pxy</span> <span class="n">nex</span><span class="p">)</span> <span class="n">str</span><span class="p">)</span> <span class="n">s'</span><span class="p">)</span>
  <span class="n">takeWhile_</span> <span class="n">f</span> <span class="p">(</span><span class="kt">MyStream</span> <span class="n">str</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s'</span><span class="p">)</span> <span class="o">=</span> <span class="kt">DL</span><span class="o">.</span><span class="n">span</span> <span class="n">f</span> <span class="n">s</span>
    <span class="kr">in</span> <span class="kr">case</span> <span class="kt">NE</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="n">x</span> <span class="kr">of</span>
      <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">MyStream</span> <span class="n">str</span> <span class="n">s'</span><span class="p">)</span>
      <span class="kt">Just</span> <span class="n">nex</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kt">MyStream</span> <span class="p">(</span><span class="n">drop</span> <span class="p">(</span><span class="n">tokensLength</span> <span class="n">pxy</span> <span class="n">nex</span><span class="p">)</span> <span class="n">str</span><span class="p">)</span> <span class="n">s'</span><span class="p">)</span>
  <span class="n">showTokens</span> <span class="kt">Proxy</span> <span class="o">=</span> <span class="kt">DL</span><span class="o">.</span><span class="n">intercalate</span> <span class="s">" "</span>
    <span class="o">.</span> <span class="kt">NE</span><span class="o">.</span><span class="n">toList</span>
    <span class="o">.</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">showMyToken</span> <span class="o">.</span> <span class="n">tokenVal</span><span class="p">)</span>
  <span class="n">tokensLength</span> <span class="kt">Proxy</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">tokenLength</span> <span class="o">&lt;$&gt;</span> <span class="n">xs</span><span class="p">)</span>
  <span class="n">reachOffset</span> <span class="n">o</span> <span class="kt">PosState</span> <span class="p">{</span><span class="o">..</span><span class="p">}</span> <span class="o">=</span>
    <span class="p">(</span> <span class="n">prefix</span> <span class="o">++</span> <span class="n">restOfLine</span>
    <span class="p">,</span> <span class="kt">PosState</span>
        <span class="p">{</span> <span class="n">pstateInput</span> <span class="o">=</span> <span class="kt">MyStream</span>
            <span class="p">{</span> <span class="n">myStreamInput</span> <span class="o">=</span> <span class="n">postStr</span>
            <span class="p">,</span> <span class="n">unMyStream</span> <span class="o">=</span> <span class="n">post</span>
            <span class="p">}</span>
        <span class="p">,</span> <span class="n">pstateOffset</span> <span class="o">=</span> <span class="n">max</span> <span class="n">pstateOffset</span> <span class="n">o</span>
        <span class="p">,</span> <span class="n">pstateSourcePos</span> <span class="o">=</span> <span class="n">newSourcePos</span>
        <span class="p">,</span> <span class="n">pstateTabWidth</span> <span class="o">=</span> <span class="n">pstateTabWidth</span>
        <span class="p">,</span> <span class="n">pstateLinePrefix</span> <span class="o">=</span> <span class="n">prefix</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="kr">where</span>
      <span class="n">prefix</span> <span class="o">=</span>
        <span class="kr">if</span> <span class="n">sameLine</span>
          <span class="kr">then</span> <span class="n">pstateLinePrefix</span> <span class="o">++</span> <span class="n">preStr</span>
          <span class="kr">else</span> <span class="n">preStr</span>
      <span class="n">sameLine</span> <span class="o">=</span> <span class="n">sourceLine</span> <span class="n">newSourcePos</span> <span class="o">==</span> <span class="n">sourceLine</span> <span class="n">pstateSourcePos</span>
      <span class="n">newSourcePos</span> <span class="o">=</span>
        <span class="kr">case</span> <span class="n">post</span> <span class="kr">of</span>
          <span class="kt">[]</span> <span class="o">-&gt;</span> <span class="n">pstateSourcePos</span>
          <span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="kr">_</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">startPos</span> <span class="n">x</span>
      <span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">post</span><span class="p">)</span> <span class="o">=</span> <span class="n">splitAt</span> <span class="p">(</span><span class="n">o</span> <span class="o">-</span> <span class="n">pstateOffset</span><span class="p">)</span> <span class="p">(</span><span class="n">unMyStream</span> <span class="n">pstateInput</span><span class="p">)</span>
      <span class="p">(</span><span class="n">preStr</span><span class="p">,</span> <span class="n">postStr</span><span class="p">)</span> <span class="o">=</span> <span class="n">splitAt</span> <span class="n">tokensConsumed</span> <span class="p">(</span><span class="n">myStreamInput</span> <span class="n">pstateInput</span><span class="p">)</span>
      <span class="n">tokensConsumed</span> <span class="o">=</span>
        <span class="kr">case</span> <span class="kt">NE</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="n">pre</span> <span class="kr">of</span>
          <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="mi">0</span>
          <span class="kt">Just</span> <span class="n">nePre</span> <span class="o">-&gt;</span> <span class="n">tokensLength</span> <span class="n">pxy</span> <span class="n">nePre</span>
      <span class="n">restOfLine</span> <span class="o">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span> <span class="sc">'</span><span class="se">\n</span><span class="sc">'</span><span class="p">)</span> <span class="n">postStr</span>

<span class="n">pxy</span> <span class="o">::</span> <span class="kt">Proxy</span> <span class="kt">MyStream</span>
<span class="n">pxy</span> <span class="o">=</span> <span class="kt">Proxy</span>

<span class="n">showMyToken</span> <span class="o">::</span> <span class="kt">MyToken</span> <span class="o">-&gt;</span> <span class="kt">String</span>
<span class="n">showMyToken</span> <span class="o">=</span> <span class="nf">\</span><span class="kr">case</span>
  <span class="p">(</span><span class="kt">Int</span> <span class="n">n</span><span class="p">)</span>    <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">n</span>
  <span class="kt">Plus</span>       <span class="o">-&gt;</span> <span class="s">"+"</span>
  <span class="kt">Mul</span>        <span class="o">-&gt;</span> <span class="s">"*"</span>
  <span class="kt">Div</span>        <span class="o">-&gt;</span> <span class="s">"/"</span>
  <span class="kt">OpenParen</span>  <span class="o">-&gt;</span> <span class="s">"("</span>
  <span class="kt">CloseParen</span> <span class="o">-&gt;</span> <span class="s">")"</span>
</code></pre>
            </div>
          </div>

          <p>
            更多关于
            <code class="language-plaintext highlighter-rouge">Stream</code>
            类型类的背景资料（以及为什么它长这样）可以在<a
              href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html"
              >这篇博客</a
            >中找到。
          </p>

          <p>
            现在我们可以为自定义的流定义
            <code class="language-plaintext highlighter-rouge">Parser</code>
            了：
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="kr">type</span> <span class="kt">Parser</span> <span class="o">=</span> <span class="kt">Parsec</span> <span class="kt">Void</span> <span class="kt">MyStream</span>
</code></pre>
            </div>
          </div>

          <p>
            下一步是基于
            <code class="language-plaintext highlighter-rouge">token</code> 和
            <code class="language-plaintext highlighter-rouge">tokens</code>
            两个原语，定义基本的语法分析器了。对于原生支持的流我们有
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Byte</code
            >
            和
            <code class="language-plaintext highlighter-rouge"
              >Text.Megaparsec.Char</code
            >
            模块，但要使用自定义的单词，我们需要自定义工具函数。
          </p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">liftMyToken</span> <span class="o">::</span> <span class="kt">MyToken</span> <span class="o">-&gt;</span> <span class="kt">WithPos</span> <span class="kt">MyToken</span>
<span class="n">liftMyToken</span> <span class="n">myToken</span> <span class="o">=</span> <span class="kt">WithPos</span> <span class="n">pos</span> <span class="n">pos</span> <span class="mi">0</span> <span class="n">myToken</span>
  <span class="kr">where</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">initialPos</span> <span class="s">""</span>

<span class="n">pToken</span> <span class="o">::</span> <span class="kt">MyToken</span> <span class="o">-&gt;</span> <span class="kt">Parser</span> <span class="kt">MyToken</span>
<span class="n">pToken</span> <span class="n">c</span> <span class="o">=</span> <span class="n">token</span> <span class="n">test</span> <span class="p">(</span><span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="o">.</span> <span class="kt">Tokens</span> <span class="o">.</span> <span class="n">nes</span> <span class="o">.</span> <span class="n">liftMyToken</span> <span class="o">$</span> <span class="n">c</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">test</span> <span class="p">(</span><span class="kt">WithPos</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">x</span><span class="p">)</span> <span class="o">=</span>
      <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">c</span>
        <span class="kr">then</span> <span class="kt">Just</span> <span class="n">x</span>
        <span class="kr">else</span> <span class="kt">Nothing</span>
    <span class="n">nes</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">:|</span> <span class="kt">[]</span>

<span class="n">pInt</span> <span class="o">::</span> <span class="kt">Parser</span> <span class="kt">Int</span>
<span class="n">pInt</span> <span class="o">=</span> <span class="n">token</span> <span class="n">test</span> <span class="kt">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">&lt;?&gt;</span> <span class="s">"integer"</span>
  <span class="kr">where</span>
    <span class="n">test</span> <span class="p">(</span><span class="kt">WithPos</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Int</span> <span class="n">n</span><span class="p">))</span> <span class="o">=</span> <span class="kt">Just</span> <span class="n">n</span>
    <span class="n">test</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>
</code></pre>
            </div>
          </div>

          <p>最后让我们写一个语法分析器测试一下加法表达式：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">pSum</span> <span class="o">=</span> <span class="kr">do</span>
  <span class="n">a</span> <span class="o">&lt;-</span> <span class="n">pInt</span>
  <span class="kr">_</span> <span class="o">&lt;-</span> <span class="n">pToken</span> <span class="kt">Plus</span>
  <span class="n">b</span> <span class="o">&lt;-</span> <span class="n">pInt</span>
  <span class="n">return</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>这里是一个样例输入：</p>

          <div class="language-haskell highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="n">exampleStream</span> <span class="o">::</span> <span class="kt">MyStream</span>
<span class="n">exampleStream</span> <span class="o">=</span> <span class="kt">MyStream</span>
  <span class="s">"5 + 6"</span>
  <span class="p">[</span> <span class="n">at</span> <span class="mi">1</span> <span class="mi">1</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">5</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">at</span> <span class="mi">1</span> <span class="mi">3</span> <span class="kt">Div</span>         <span class="c1">-- (1)</span>
  <span class="p">,</span> <span class="n">at</span> <span class="mi">1</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Int</span> <span class="mi">6</span><span class="p">)</span>
  <span class="p">]</span>
  <span class="kr">where</span>
    <span class="n">at</span>  <span class="n">l</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">WithPos</span> <span class="p">(</span><span class="n">at'</span> <span class="n">l</span> <span class="n">c</span><span class="p">)</span> <span class="p">(</span><span class="n">at'</span> <span class="n">l</span> <span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">2</span>
    <span class="n">at'</span> <span class="n">l</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">SourcePos</span> <span class="s">""</span> <span class="p">(</span><span class="n">mkPos</span> <span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">mkPos</span> <span class="n">c</span><span class="p">)</span>
</code></pre>
            </div>
          </div>

          <p>让我们试一下：</p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pSum &lt;* eof) exampleStream
(5,6)
</code></pre>
            </div>
          </div>

          <p>
            如果我们把 (1) 处的
            <code class="language-plaintext highlighter-rouge">Plus</code> 改成
            <code class="language-plaintext highlighter-rouge">Div</code
            >，我们也能得到正确的错误信息：
          </p>

          <div class="language-plaintext highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code>λ&gt; parseTest (pSum &lt;* eof) exampleStream
1:3:
  |
1 | 5 + 6
  |   ^^
unexpected /
expecting +
</code></pre>
            </div>
          </div>

          <p>换言之，我们拥有一个能够处理自定义流的功能完备的语法分析器了。</p>
          <div class="footnotes" role="doc-endnotes">
            <ol>
              <li id="fn:modern-uri" role="doc-endnote">
                <p>
                  实际上有个
                  <a href="https://hackage.haskell.org/package/modern-uri"
                    >modern-uri</a
                  >
                  包，其 Megaparsec 语法分析器支持 RFC 3986 定义的 URI
                  格式，但它远比我们这里介绍的要复杂。 <a
                    href="#fnref:modern-uri"
                    class="reversefootnote"
                    role="doc-backlink"
                    >&#8617;</a
                  >
                </p>
              </li>
            </ol>
          </div>
        </div>

        <div class="comments">
          <div id="disqus_thread"></div>
          <script>
            var disqus_config = function () {
              this.page.url = "https://blog.yzsun.me/megaparsec/";
              this.page.identifier = "/megaparsec/";
            };
            (function () {
              var d = document,
                s = d.createElement("script");
              s.src = "//yzyzsun.disqus.com/embed.js";
              s.setAttribute("data-timestamp", +new Date());
              (d.head || d.body).appendChild(s);
            })();
          </script>
          <noscript
            >Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript"
              >comments powered by Disqus.</a
            ></noscript
          >
        </div>
      </article>
    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <a href="https://github.com/yzyzsun"
            ><i class="svg-icon github"></i
          ></a>

          <a href="/feed.xml"><i class="svg-icon rss"></i></a>
        </footer>
      </div>
    </div>

    <!-- Google Analytics -->
    <script>
      (function (i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r;
        (i[r] =
          i[r] ||
          function () {
            (i[r].q = i[r].q || []).push(arguments);
          }),
          (i[r].l = 1 * new Date());
        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      );

      ga("create", "UA-65994616-1", "auto");
      ga("send", "pageview", {
        page: "/megaparsec/",
        title: "Megaparsec: Haskell 的语法分析组合子",
      });
    </script>
    <!-- End Google Analytics -->
  </body>
</html>
