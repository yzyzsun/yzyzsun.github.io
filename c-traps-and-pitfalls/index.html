<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <title>《C 陷阱与缺陷》笔记 | 孙耀珠的博客</title>

    <meta charset="utf-8" />
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0"
    />
    <meta
      name="google-site-verification"
      content="zYt2wigM41vmyHtpvOvLHk4Yetcfbv5Bz9pdvsTRT3Y"
    />

    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <meta name="generator" content="Jekyll v4.2.0" />
    <meta property="og:title" content="《C 陷阱与缺陷》笔记" />
    <meta name="author" content="孙耀珠" />
    <meta property="og:locale" content="en_US" />
    <meta
      name="description"
      content="词法陷阱（Lexical pitfalls） 词法陷阱（Lexical pitfalls） 由 ALGOL 派生的编程语言如 Pascal 和 Ada，使用 := 作为赋值运算符，而 = 作为比较运算符。C 语言则使用了另一种表示法，以 = 为赋值运算符，以 == 为比较运算符。 在 C 语言中，&amp; 和 | 是按位运算符，而 &amp;&amp; 和 || 是逻辑运算符。另外，^ 表示按位异或，而不是乘方。 C 编译器在词法分析时遵从贪心法，比如 y = x/*p 的 /* 会被理解为注释的开始，而不是 y = x / *p。 0 开头的整型字面量将被视为八进制，因此切忌用 0 来占位对齐。 单引号引起的一个字符实际上代表一个整数，而用双引号引起的字符串代表一个无名的字符数组。如果误用单引号引起一个字符串，使用 Clang 等编译器会得到最后一个字符的整数值，而其他编译器也可能得到第一个字符的整数值。"
    />
    <meta
      property="og:description"
      content="词法陷阱（Lexical pitfalls） 词法陷阱（Lexical pitfalls） 由 ALGOL 派生的编程语言如 Pascal 和 Ada，使用 := 作为赋值运算符，而 = 作为比较运算符。C 语言则使用了另一种表示法，以 = 为赋值运算符，以 == 为比较运算符。 在 C 语言中，&amp; 和 | 是按位运算符，而 &amp;&amp; 和 || 是逻辑运算符。另外，^ 表示按位异或，而不是乘方。 C 编译器在词法分析时遵从贪心法，比如 y = x/*p 的 /* 会被理解为注释的开始，而不是 y = x / *p。 0 开头的整型字面量将被视为八进制，因此切忌用 0 来占位对齐。 单引号引起的一个字符实际上代表一个整数，而用双引号引起的字符串代表一个无名的字符数组。如果误用单引号引起一个字符串，使用 Clang 等编译器会得到最后一个字符的整数值，而其他编译器也可能得到第一个字符的整数值。"
    />
    <link rel="canonical" href="https://blog.yzsun.me/c-traps-and-pitfalls/" />
    <meta
      property="og:url"
      content="https://blog.yzsun.me/c-traps-and-pitfalls/"
    />
    <meta property="og:site_name" content="孙耀珠的博客" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2015-06-07T00:00:00+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="《C 陷阱与缺陷》笔记" />
    <script type="application/ld+json">
      {
        "description": "词法陷阱（Lexical pitfalls） 词法陷阱（Lexical pitfalls） 由 ALGOL 派生的编程语言如 Pascal 和 Ada，使用 := 作为赋值运算符，而 = 作为比较运算符。C 语言则使用了另一种表示法，以 = 为赋值运算符，以 == 为比较运算符。 在 C 语言中，&amp; 和 | 是按位运算符，而 &amp;&amp; 和 || 是逻辑运算符。另外，^ 表示按位异或，而不是乘方。 C 编译器在词法分析时遵从贪心法，比如 y = x/*p 的 /* 会被理解为注释的开始，而不是 y = x / *p。 0 开头的整型字面量将被视为八进制，因此切忌用 0 来占位对齐。 单引号引起的一个字符实际上代表一个整数，而用双引号引起的字符串代表一个无名的字符数组。如果误用单引号引起一个字符串，使用 Clang 等编译器会得到最后一个字符的整数值，而其他编译器也可能得到第一个字符的整数值。",
        "url": "https://blog.yzsun.me/c-traps-and-pitfalls/",
        "@type": "BlogPosting",
        "headline": "《C 陷阱与缺陷》笔记",
        "dateModified": "2015-06-07T00:00:00+00:00",
        "datePublished": "2015-06-07T00:00:00+00:00",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.yzsun.me/c-traps-and-pitfalls/"
        },
        "author": { "@type": "Person", "name": "孙耀珠" },
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.yzsun.me/feed.xml"
      title="孙耀珠的博客"
    />

    <!--[if lt IE 9]>
      <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/r29/html5.min.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="/style.css" />
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"
            ><img src="/images/avatar.jpg" alt="avatar"
          /></a>

          <div class="site-info">
            <h1 class="site-domain"><a href="/">yzsun.me</a></h1>
            <p class="site-name">孙耀珠的博客</p>
          </div>

          <nav>
            <a href="/">首页</a>
            <a href="/archive/">归档</a>
            <a href="/about/">关于</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
        <h1>《C 陷阱与缺陷》笔记</h1>

        <div class="info">
          <span>
            <i class="fa fa-calendar"></i>
            2015-06-07
          </span>
          <span>
            <i class="fa fa-user"></i>
            孙耀珠
          </span>
          <span>
            <i class="fa fa-tags"></i>
            编程语言
          </span>
        </div>

        <div class="entry">
          <ul id="markdown-toc">
            <li>
              <a
                href="#词法陷阱lexical-pitfalls"
                id="markdown-toc-词法陷阱lexical-pitfalls"
                >词法陷阱（Lexical pitfalls）</a
              >
            </li>
            <li>
              <a
                href="#语法陷阱syntactic-pitfalls"
                id="markdown-toc-语法陷阱syntactic-pitfalls"
                >语法陷阱（Syntactic pitfalls）</a
              >
            </li>
            <li>
              <a
                href="#语义陷阱semantic-pitfalls"
                id="markdown-toc-语义陷阱semantic-pitfalls"
                >语义陷阱（Semantic pitfalls）</a
              >
            </li>
            <li>
              <a href="#连接linkage" id="markdown-toc-连接linkage"
                >连接（Linkage）</a
              >
            </li>
            <li>
              <a
                href="#库函数library-functions"
                id="markdown-toc-库函数library-functions"
                >库函数（Library functions）</a
              >
            </li>
            <li>
              <a
                href="#预处理器preprocessor"
                id="markdown-toc-预处理器preprocessor"
                >预处理器（Preprocessor）</a
              >
            </li>
            <li>
              <a
                href="#可移植性缺陷portability-pitfalls"
                id="markdown-toc-可移植性缺陷portability-pitfalls"
                >可移植性缺陷（Portability pitfalls）</a
              >
            </li>
          </ul>

          <h2 id="词法陷阱lexical-pitfalls">词法陷阱（Lexical pitfalls）</h2>

          <ul>
            <li>
              由 ALGOL 派生的编程语言如 Pascal 和 Ada，使用
              <code class="language-plaintext highlighter-rouge">:=</code>
              作为赋值运算符，而
              <code class="language-plaintext highlighter-rouge">=</code>
              作为比较运算符。C 语言则使用了另一种表示法，以
              <code class="language-plaintext highlighter-rouge">=</code>
              为赋值运算符，以
              <code class="language-plaintext highlighter-rouge">==</code>
              为比较运算符。
            </li>
            <li>
              在 C 语言中，<code class="language-plaintext highlighter-rouge"
                >&amp;</code
              >
              和
              <code class="language-plaintext highlighter-rouge">|</code>
              是按位运算符，而
              <code class="language-plaintext highlighter-rouge"
                >&amp;&amp;</code
              >
              和
              <code class="language-plaintext highlighter-rouge">||</code>
              是逻辑运算符。另外，<code
                class="language-plaintext highlighter-rouge"
                >^</code
              >
              表示按位异或，而不是乘方。
            </li>
            <li>
              C 编译器在词法分析时遵从贪心法，比如
              <code class="language-plaintext highlighter-rouge">y = x/*p</code>
              的
              <code class="language-plaintext highlighter-rouge">/*</code>
              会被理解为注释的开始，而不是
              <code class="language-plaintext highlighter-rouge"
                >y = x / *p</code
              >。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">0</code>
              开头的整型字面量将被视为八进制，因此切忌用
              <code class="language-plaintext highlighter-rouge">0</code>
              来占位对齐。
            </li>
            <li>
              单引号引起的一个字符实际上代表一个整数，而用双引号引起的字符串代表一个无名的字符数组。如果误用单引号引起一个字符串，使用
              Clang
              等编译器会得到最后一个字符的整数值，而其他编译器也可能得到第一个字符的整数值。
            </li>
          </ul>

          <!--more-->

          <h2 id="语法陷阱syntactic-pitfalls">
            语法陷阱（Syntactic pitfalls）
          </h2>

          <ul>
            <li>
              变量声明的含义为，右边表达式的值为左边所述的类型。同样的逻辑对于指针和函数声明也适用，如
              <code class="language-plaintext highlighter-rouge"
                >const char *(*f)()</code
              >
              表示
              <code class="language-plaintext highlighter-rouge">f</code>
              指向的函数返回值也是一个指针，它指向字符串常量。同时只需要将变量名去掉并在最外面加上圆括号，便可以得到该类型的类型转换符。
            </li>
            <li>关于运算符优先级的常见错误：</li>
          </ul>

          <div class="language-c highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FLAG</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">...</span>
<span class="c1">// &lt;=&gt; if (flags &amp; (FLAGS != 0)) ...</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">hi</span><span class="o">&lt;&lt;</span><span class="mi">4</span> <span class="o">+</span> <span class="n">low</span>
<span class="c1">// &lt;=&gt; r = hi &lt;&lt; (4 + low)</span>
<span class="c1">// SHOULD BE: r = hi&lt;&lt;4 | low</span>

<span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">getc</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="n">putc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
<span class="c1">// &lt;=&gt; c = (getc(in) != EOF)</span>
</code></pre>
            </div>
          </div>

          <table>
            <thead>
              <tr>
                <th>运算符</th>
                <th>结合性</th>
                <th>分类</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">()</code>
                  <code class="language-plaintext highlighter-rouge">[]</code>
                  <code class="language-plaintext highlighter-rouge"
                    >-&gt;</code
                  >
                  <code class="language-plaintext highlighter-rouge">.</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">!</code>
                  <code class="language-plaintext highlighter-rouge">~</code>
                  <code class="language-plaintext highlighter-rouge">++</code>
                  <code class="language-plaintext highlighter-rouge">--</code>
                  <code class="language-plaintext highlighter-rouge">-</code>
                  <code class="language-plaintext highlighter-rouge"
                    >(type)</code
                  >
                  <code class="language-plaintext highlighter-rouge">*</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >sizeof</code
                  >
                </td>
                <td>←</td>
                <td>单目运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">*</code>
                  <code class="language-plaintext highlighter-rouge">/</code>
                  <code class="language-plaintext highlighter-rouge">%</code>
                </td>
                <td>→</td>
                <td>算术运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">+</code>
                  <code class="language-plaintext highlighter-rouge">-</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >&lt;&lt;</code
                  >
                  <code class="language-plaintext highlighter-rouge"
                    >&gt;&gt;</code
                  >
                </td>
                <td>→</td>
                <td>移位运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">&lt;</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&lt;=</code
                  >
                  <code class="language-plaintext highlighter-rouge">&gt;</code>
                  <code class="language-plaintext highlighter-rouge"
                    >&gt;=</code
                  >
                </td>
                <td>→</td>
                <td>关系运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">==</code>
                  <code class="language-plaintext highlighter-rouge">!=</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;</code
                  >
                </td>
                <td>→</td>
                <td>按位运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">^</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">|</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge"
                    >&amp;&amp;</code
                  >
                </td>
                <td>→</td>
                <td>逻辑运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">||</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">?:</code>
                </td>
                <td>←</td>
                <td>三目运算符</td>
              </tr>
              <tr>
                <td>assignments</td>
                <td>←</td>
                <td>赋值运算符</td>
              </tr>
              <tr>
                <td>
                  <code class="language-plaintext highlighter-rouge">,</code>
                </td>
                <td>→</td>
                <td> </td>
              </tr>
            </tbody>
          </table>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">switch</code>
              语句的
              <code class="language-plaintext highlighter-rouge">case</code>
              只是一个标号，分支结束不加
              <code class="language-plaintext highlighter-rouge">break</code>
              控制流程会穿过下一个
              <code class="language-plaintext highlighter-rouge">case</code>
              标号。
            </li>
            <li>
              调用无参函数时仍需要括号，否则单独的函数名只是计算函数的地址，而不会调用它。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">else</code>
              始终跟最近的
              <code class="language-plaintext highlighter-rouge">if</code>
              匹配，即使这两句没有被外层花括号包围。
            </li>
          </ul>

          <div class="language-c highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">f</span><span class="p">();</span>
<span class="k">else</span>
    <span class="nf">g</span><span class="p">();</span>

<span class="cm">/* 等价于 */</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="n">f</span><span class="p">();</span>
    <span class="k">else</span> <span class="n">g</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h2 id="语义陷阱semantic-pitfalls">语义陷阱（Semantic pitfalls）</h2>

          <ul>
            <li>
              数组的所有操作都是通过指针实现的，如
              <code class="language-plaintext highlighter-rouge">a[i]</code>
              等价于
              <code class="language-plaintext highlighter-rouge">*(a + i)</code
              >，因此该表达式也可以写成
              <code class="language-plaintext highlighter-rouge">i[a]</code>。
            </li>
            <li>
              除了进行
              <code class="language-plaintext highlighter-rouge">&amp;</code> 和
              <code class="language-plaintext highlighter-rouge">sizeof</code>
              运算，数组名都会被转换为一个指向其起始元素的指针。而
              <code class="language-plaintext highlighter-rouge"
                >&amp;array</code
              >
              会返回一个指向数组的指针类型，其值仍为起始元素的地址。
            </li>
            <li>
              对于二维数组，它实际上相当于以数组为元素的数组，其下标和数组名的行为也是类似的。
            </li>
            <li>
              如果使用数组名作为函数参数，那么它会被立即转换为指针。因此 C
              语言会自动把作为参数的数组声明转换为相应的指针声明。如
              <code class="language-plaintext highlighter-rouge"
                >size_t strlen(char s[])</code
              >
              等价于
              <code class="language-plaintext highlighter-rouge"
                >size_t strlen(char *s)</code
              >。
            </li>
            <li>
              在 C
              语言中，字符串字面量是一个编译时便初始化好的字符数组，对其做出修改可能会触发
              bus error（OS X）。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge"
                >&amp;&amp;</code
              >
              和
              <code class="language-plaintext highlighter-rouge">||</code>
              遵循短路求值的原则，只有当左操作数无法确定逻辑运算的结果时，才对右操作数求值。
            </li>
            <li>
              如果没有为函数声明返回类型，那么返回类型默认为
              <code class="language-plaintext highlighter-rouge">int</code
              >。如果在主函数中没有写
              <code class="language-plaintext highlighter-rouge">return</code>
              语句，Clang 等编译器会自动加上
              <code class="language-plaintext highlighter-rouge">return 0</code
              >。
            </li>
          </ul>

          <h2 id="连接linkage">连接（Linkage）</h2>

          <ul>
            <li>
              通常 C
              编译器（cc）等组件只负责独立地将每个源文件（.c）编译为目标文件（.o），因此利用目标文件和库文件生成可执行文件的工作都交给与
              C 语言不相关的连接器（ld），包括处理命名冲突和外部引用。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge">extern</code>
              关键字可以声明外部变量，该变量的定义既可以在同一源文件内，也可以在不同源文件中。
            </li>
            <li>
              同一工程中不允许出现同名的全局变量或函数，这时使用
              <code class="language-plaintext highlighter-rouge">static</code>
              关键字可以将其作用域限制在源文件内，以解决命名冲突的问题。
            </li>
            <li>
              如果一个函数在被定义或声明前被调用，那么它的返回值默认为
              <code class="language-plaintext highlighter-rouge">int</code>。
            </li>
            <li>
              如果没有对函数形参类型进行声明，则调用时
              <code class="language-plaintext highlighter-rouge">float</code>
              类型参数会自动转换为
              <code class="language-plaintext highlighter-rouge">double</code>
              类型，<code class="language-plaintext highlighter-rouge"
                >char</code
              >
              和
              <code class="language-plaintext highlighter-rouge">short</code>
              会自动转换为
              <code class="language-plaintext highlighter-rouge">int</code>
              类型。<code class="language-plaintext highlighter-rouge"
                >scanf</code
              >
              和
              <code class="language-plaintext highlighter-rouge">printf</code>
              函数对参数的处理便是如此。
            </li>
            <li>
              由于无法得知 C
              语言的实现细节，连接器不检查不同源文件中的外部变量和函数声明和定义是否一致。
            </li>
            <li>
              为避免上述问题，所有的外部声明应集中在头文件中；且实现这些定义的源文件也应包含此头文件，编译成功即可确保声明的正确性。
            </li>
          </ul>

          <h2 id="库函数library-functions">库函数（Library functions）</h2>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">getchar</code>
              函数的返回值为
              <code class="language-plaintext highlighter-rouge">int</code>
              类型，如果读取成功会将
              <code class="language-plaintext highlighter-rouge"
                >unsigned char</code
              >
              转换为
              <code class="language-plaintext highlighter-rouge">int</code>
              返回，否则返回
              <code class="language-plaintext highlighter-rouge">EOF</code
              >（-1）。若将
              <code class="language-plaintext highlighter-rouge">getchar</code>
              返回值赋给
              <code class="language-plaintext highlighter-rouge">char</code>
              类型，可能会导致 255 与 -1 混淆。
            </li>
            <li>
              ANSI C 可通过
              <code class="language-plaintext highlighter-rouge">stdarg.h</code>
              实现可变参数列表，譬如：
            </li>
          </ul>

          <div class="language-c highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">#include &lt;stdarg.h&gt;
</span>
<span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">ap</span><span class="p">;</span> <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
    
    <span class="n">va_start</span><span class="p">(</span><span class="n">ap</span><span class="p">,</span> <span class="n">format</span><span class="p">);</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vprintf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">ap</span><span class="p">);</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">ap</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
            </div>
          </div>

          <h2 id="预处理器preprocessor">预处理器（Preprocessor）</h2>

          <ul>
            <li>在宏定义中，宏名和形参列表之间不可以有空格。</li>
            <li>
              尽量将宏定义的各个参数以及整个结果表达式用括号括起来，以免引起与优先级相关的问题。
            </li>
            <li>要确保宏中的参数没有副作用，譬如：</li>
          </ul>

          <div class="language-c highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="cp">#define max(a, b) ((a) &gt; (b) ? (a) : (b))
</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">biggest</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">biggest</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">biggest</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">++</span><span class="p">]);</span>
<span class="c1">// &lt;=&gt; biggest = ((biggest) &gt; (x[i++]) ? (biggest) : (x[i++]))</span>
<span class="c1">// i++ 可能执行两次</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>尽量不要将宏定义为语句，否则会出现难以意料的结果，譬如：</li>
          </ul>

          <div class="language-c highlighter-rouge">
            <div class="highlight">
              <pre
                class="highlight"
              ><code><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">);</span>
<span class="k">else</span>
    <span class="nf">assert</span><span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">);</span>

<span class="cp">#define assert(e) if (!(e)) assert_error(__FILE__, __LINE__)
</span><span class="c1">// 如果这样定义，会出现 if-else 的嵌套问题</span>
<span class="cp">#define assert(e) { if (!(e)) assert_error(__FILE__, __LINE__); }
</span><span class="c1">// 如果这样定义，花括号后会多出一个分号</span>
<span class="cp">#define assert(e) do { if (!(e)) assert_error(__FILE__, __LINE__); } while (0)
</span><span class="c1">// 这是一个可行的定义</span>
<span class="cp">#define assert(e) ((e) || assert_error(__FILE__, __LINE__))
</span><span class="c1">// 这是另一个可行的定义</span>
</code></pre>
            </div>
          </div>

          <ul>
            <li>
              尽量不要用宏代替
              <code class="language-plaintext highlighter-rouge">typedef</code
              >，如果
              <code class="language-plaintext highlighter-rouge"
                >#define IP int *</code
              >，则
              <code class="language-plaintext highlighter-rouge"
                >IP p1, p2;</code
              >
              中的
              <code class="language-plaintext highlighter-rouge">p2</code>
              将是整型而不是整型指针。
            </li>
          </ul>

          <h2 id="可移植性缺陷portability-pitfalls">
            可移植性缺陷（Portability pitfalls）
          </h2>

          <ul>
            <li>
              ANSI 标准要求
              <code class="language-plaintext highlighter-rouge">short</code> 和
              <code class="language-plaintext highlighter-rouge">int</code>
              至少是 16 位，<code class="language-plaintext highlighter-rouge"
                >long</code
              >
              至少是 32 位，C99 要求
              <code class="language-plaintext highlighter-rouge"
                >long long</code
              >
              至少 64 位，但没有规定确切的大小。
            </li>
          </ul>

          <table>
            <thead>
              <tr>
                <th>Data model</th>
                <th>short</th>
                <th>int</th>
                <th>long</th>
                <th>long long</th>
                <th>pointers / size_t</th>
                <th>OS</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>ILP32</td>
                <td>16</td>
                <td>32</td>
                <td>32</td>
                <td>64</td>
                <td>32</td>
                <td>Most 32-bit</td>
              </tr>
              <tr>
                <td>LLP64</td>
                <td>16</td>
                <td>32</td>
                <td>32</td>
                <td>64</td>
                <td>64</td>
                <td>Windows 64-bit</td>
              </tr>
              <tr>
                <td>LP64</td>
                <td>16</td>
                <td>32</td>
                <td>64</td>
                <td>64</td>
                <td>64</td>
                <td>Most Unix and Unix-like 64-bit</td>
              </tr>
            </tbody>
          </table>

          <ul>
            <li>
              <code class="language-plaintext highlighter-rouge">char</code>
              默认是
              <code class="language-plaintext highlighter-rouge">signed</code>
              还是
              <code class="language-plaintext highlighter-rouge">unsigned</code>
              因环境而异，如 Android NDK 中的 GCC 默认是
              <code class="language-plaintext highlighter-rouge"
                >unsigned char</code
              >。
            </li>
            <li>
              <code class="language-plaintext highlighter-rouge"
                >long double</code
              >
              的实现也因编译器而异，可能是双精度的同义词、扩展精度（extended
              precision, 80-bit）、四倍精度（quadruple precision,
              128-bit）、一对双精度浮点数（double-double arithmetic, 64-bit +
              64-bit）。为了字节对齐，扩展精度（10 字节）可能会被存储为 12 / 16
              字节。
            </li>
            <li>
              C99 规定求余结果与被除数同号，相应地，整数除法向零取整；而 C99
              以前对此没有明确的定义。
            </li>
          </ul>

          <blockquote>
            <p>
              <strong>See also</strong><br />
              <a href="http://blog.zhanghai.me/c-exam-notes/"
                >C 语言应试笔记 | 梦断代码</a
              >
            </p>
          </blockquote>
        </div>

        <div class="comments">
          <div id="disqus_thread"></div>
          <script>
            var disqus_config = function () {
              this.page.url = "https://blog.yzsun.me/c-traps-and-pitfalls/";
              this.page.identifier = "/c-traps-and-pitfalls/";
            };
            (function () {
              var d = document,
                s = d.createElement("script");
              s.src = "//yzyzsun.disqus.com/embed.js";
              s.setAttribute("data-timestamp", +new Date());
              (d.head || d.body).appendChild(s);
            })();
          </script>
          <noscript
            >Please enable JavaScript to view the
            <a href="https://disqus.com/?ref_noscript"
              >comments powered by Disqus.</a
            ></noscript
          >
        </div>
      </article>
    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <a href="https://github.com/yzyzsun"
            ><i class="svg-icon github"></i
          ></a>

          <a href="/feed.xml"><i class="svg-icon rss"></i></a>
        </footer>
      </div>
    </div>

    <!-- Google Analytics -->
    <script>
      (function (i, s, o, g, r, a, m) {
        i["GoogleAnalyticsObject"] = r;
        (i[r] =
          i[r] ||
          function () {
            (i[r].q = i[r].q || []).push(arguments);
          }),
          (i[r].l = 1 * new Date());
        (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m);
      })(
        window,
        document,
        "script",
        "//www.google-analytics.com/analytics.js",
        "ga"
      );

      ga("create", "UA-65994616-1", "auto");
      ga("send", "pageview", {
        page: "/c-traps-and-pitfalls/",
        title: "《C 陷阱与缺陷》笔记",
      });
    </script>
    <!-- End Google Analytics -->
  </body>
</html>
